<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[链表相关的算法]]></title>
    <url>%2F2019%2F03%2F25%2F%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%85%B3%E7%9A%84%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[概述数组和链表是最基础的数据结构，它们分别代表了顺序存储和随机存储，其他数据结构都可以利用数组和链表的思想构建。下面就学习一下一些基于链表的简单算法。 算法单链表12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * 功能描述: 单链表 * * @author sunzhiqiang * @create 2019-03-02 */public class SingleList&lt;T extends Comparable&lt;T&gt;&gt; &#123; public Node&lt;T&gt; head; public SingleList() &#123; head = new Node&lt;&gt;(null); &#125; public SingleList add(T t) &#123; Node&lt;T&gt; node = new Node&lt;&gt;(t); if (head.next == null) &#123; head.next = node; &#125; else &#123; node.next = head.next; head.next = node; &#125; return this; &#125; public void print() &#123; Node&lt;T&gt; first = head.next; while (first != null) &#123; System.out.print(first.data + "\t"); first = first.next; &#125; System.out.println(); &#125; public static class Node&lt;T extends Comparable&lt;T&gt;&gt; &#123; public Node next; public T data; public Node(T data) &#123; this.data = data; &#125; &#125;&#125; 单链表反转123456789101112131415161718192021222324252627282930313233import cn.com.sunzhiqiang.algorithm.link.SingleList;/** * 功能描述: 单链表反转 * * @author sunzhiqiang * @create 2019-03-01 */public class ReverseList &#123; public static void main(String[] args) &#123; // 1.初始化单链表 SingleList singleList = new SingleList(); singleList.add(1).add(2).add(3).add(4).add(5); singleList.print(); // 反转单链表 SingleList.Node p = singleList.head.next; if (p.next != null) &#123; SingleList.Node q = p.next; p.next = null; while (q != null) &#123; SingleList.Node r = q.next; q.next = p; p = q; q = r; &#125; singleList.head.next = p; &#125; singleList.print(); &#125;&#125; 单项循环列表1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * 功能描述: 单向循环链表 * * @author sunzhiqiang * @create 2019-03-02 */public class SingleCycleList&lt;T&gt; &#123; public Node&lt;T&gt; head; public SingleCycleList() &#123; head = new Node&lt;&gt;(null); &#125; public SingleCycleList add(T t) &#123; Node&lt;T&gt; node = new Node&lt;&gt;(t); if (head.next == null) &#123; head.next = node; node.next = head.next; &#125; else &#123; node.next = head.next; head.next = node; &#125; return this; &#125; public void print() &#123; Node&lt;T&gt; first = head.next; while (first != null) &#123; System.out.print(first.data + "\t"); first = first.next; &#125; System.out.println(); &#125; public static class Node&lt;T&gt; &#123; public Node next; public T data; public Node(T data) &#123; this.data = data; &#125; &#125;&#125; 链表中环检测1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import cn.com.sunzhiqiang.algorithm.link.SingleCycleList;import cn.com.sunzhiqiang.algorithm.link.SingleList;/** * 功能描述: 单链表中环的检测 * * @author sunzhiqiang * @create 2019-03-02 */public class RingDetection &#123; public static void main(String[] args) &#123; // 单链表 SingleList&lt;Integer&gt; singleList = new SingleList&lt;&gt;(); singleList.add(5).add(4).add(3).add(2).add(1); // 单向循环列表 SingleCycleList&lt;Integer&gt; singleCycleList = new SingleCycleList&lt;&gt;(); singleCycleList.add(5).add(4).add(3).add(2).add(1); // 环检测 boolean isHasCycle = detectCycle(singleCycleList); System.out.println(isHasCycle); isHasCycle = detectCycle2(singleList); System.out.println(isHasCycle); &#125; private static boolean detectCycle(SingleCycleList&lt;Integer&gt; singleCycleList) &#123; SingleCycleList.Node fast = singleCycleList.head.next; SingleCycleList.Node slow = singleCycleList.head.next; while (fast != null) &#123; fast = fast.next; if (fast != null) &#123; fast = fast.next; &#125; else &#123; return false; &#125; slow = slow.next; if (fast == slow) &#123; return true; &#125; &#125; return false; &#125; private static boolean detectCycle2(SingleList&lt;Integer&gt; singleList) &#123; SingleList.Node fast = singleList.head.next; SingleList.Node slow = singleList.head.next; while (fast != null) &#123; fast = fast.next; if (fast != null) &#123; fast = fast.next; &#125; else &#123; return false; &#125; slow = slow.next; if (fast == slow) &#123; return true; &#125; &#125; return false; &#125;&#125; 2个有序单链表的合并12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import cn.com.sunzhiqiang.algorithm.link.SingleList;/** * 功能描述: 2个有序的单链表合并 * * @author sunzhiqiang * @create 2019-03-02 */public class MergeSortLink &#123; public static void main(String[] args) &#123; // 单链表1 SingleList&lt;Integer&gt; singleList = new SingleList&lt;&gt;(); singleList.add(11).add(10).add(5).add(3).add(1); // 单链表2 SingleList&lt;Integer&gt; singleList2 = new SingleList&lt;&gt;(); singleList2.add(12).add(8).add(6).add(4).add(0); // 合并 SingleList.Node one = singleList.head.next; SingleList.Node two = singleList2.head.next; SingleList newLink = new SingleList(); if (one == null) &#123; newLink.head.next = two; &#125; else if (two == null) &#123; newLink.head.next = one; &#125; else if (one.data.compareTo(two.data) &gt; 0) &#123; newLink.head.next = two; &#125; else &#123; newLink.head.next = one; &#125; SingleList.Node nextNode = null; SingleList.Node pre = null; while (one != null &amp;&amp; two != null) &#123; if (one.data.compareTo(two.data) &gt; 0) &#123; nextNode = two.next; two.next = one; if (pre != null) &#123; pre.next = two; &#125; pre = two; two = nextNode; &#125; else &#123; nextNode = one.next; one.next = two; if (pre != null) &#123; pre.next = one; &#125; pre = one; one = nextNode; &#125; &#125; newLink.print(); &#125;&#125; 删除链表倒数第n个结点1234567891011121314151617181920212223242526272829303132333435import cn.com.sunzhiqiang.algorithm.link.SingleList;/** * 功能描述: 删除链表倒数第n个位置的元素 * * @author sunzhiqiang * @create 2019-03-03 */public class DeleteOfNPostion &#123; public static void main(String[] args) &#123; // 创建单链表 SingleList&lt;Integer&gt; singleList = new SingleList&lt;&gt;(); singleList.add(5).add(4).add(3).add(2).add(1); singleList.print(); // 要删除的位置（倒数） int deletePositon = 4; SingleList.Node first = singleList.head.next; int count = 0; while (first != null) &#123; count++; first = first.next; &#125; int positivePostion = count - deletePositon; first = singleList.head.next; for (int i = 1; i &lt; positivePostion; i++) &#123; first = first.next; &#125; SingleList.Node deleteNode = first.next; first.next = deleteNode.next; singleList.print(); &#125;&#125; 求链表的中间结点1234567891011121314151617181920212223242526272829303132import cn.com.sunzhiqiang.algorithm.link.SingleList;/** * 功能描述: 求链表的中点 * * @author sunzhiqiang * @create 2019-03-03 */public class MidPoint &#123; public static void main(String[] args) &#123; // 创建一个单链表 SingleList singleList = new SingleList(); singleList.add(5).add(4).add(3).add(2).add(1).add(0); singleList.print(); // 获取链表的中间结点 SingleList.Node fast = singleList.head.next; SingleList.Node slow = singleList.head.next; while (fast != null) &#123; fast = fast.next; if (fast == null) &#123; break; &#125; fast = fast.next; slow = slow.next; &#125; System.out.println(slow.data); &#125;&#125; 多个有序列表的合并1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889/** * 功能描述: 合并K个有序链表 * * @author sunzhiqiang * @create 2019-03-06 */public class Solution &#123; public static class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; &#125; &#125; public static void main(String[] args) &#123; ListNode[] listNodes = new ListNode[3]; ListNode one = new ListNode(1); one.next = new ListNode(4); one.next.next = new ListNode(5); ListNode two = new ListNode(1); two.next = new ListNode(3); two.next.next = new ListNode(4); ListNode three = new ListNode(2); three.next = new ListNode(6); listNodes[0] = one; listNodes[1] = two; listNodes[2] = three; ListNode result = mergeKLists(listNodes); while (result != null) &#123; System.out.print(result.val + "\t"); result = result.next; &#125; &#125; public static ListNode mergeKLists(ListNode[] lists) &#123; if (lists == null || lists.length == 0) &#123; return null; &#125; ListNode newListNode = null; ListNode one = lists[0]; for (int i = 1; i &lt; lists.length; i++) &#123; ListNode two = lists[i]; if (one == null)&#123; newListNode = two; &#125;else if (two == null) &#123; newListNode = one; &#125; else if (one.val &gt; two.val) &#123; newListNode = two; &#125; else &#123; newListNode = one; &#125; ListNode newHead = null; ListNode preNode = null; while (one != null &amp;&amp; two != null) &#123; if (one.val &gt; two.val) &#123; newHead = two.next; if (preNode != null) &#123; preNode.next = two; &#125; two.next = one; preNode = two; two = newHead; &#125;else &#123; newHead = one.next; if (preNode != null) &#123; preNode.next = one; &#125; one.next = two; preNode = one; one = newHead; &#125; &#125; one = newListNode; &#125; return one; &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[实现一个简易的HashMap]]></title>
    <url>%2F2019%2F03%2F12%2F%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93%E7%9A%84HashMap%2F</url>
    <content type="text"><![CDATA[概述HashMap基于数组加链表实现，在hash算法设计的足够好的情况下，可以实现O(1)的查找，删除，新增。效率极高，JDK核心类库里的HashMap设计的十分巧妙。尤其是下面这几点： 使用&amp;运算符高效取余 使用位运算符巧妙的设置数组的容量为2的n次幂 hash函数设计的也很高效 resize方法里rehash的方式也非常巧妙 在哈希冲突较多时，使用红黑树代替链表 HashMap的设计hash函数1234static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125; 如上面的代码所展示的，hash函数的第一步是去key的hashcode,通过hashcode映射到数组的某一个下标，相当于除以数组的长度取余，余数是多少其实只取决于hashcode的低位。所以hash函数将hashcode的高16位于低16位异或，来增加hash的离散性。 &amp;运算符取余1(n - 1) &amp; hash 其中n为数组的长度，这里有个前提，数组的长度是2的幂次，也就是形如0000100000的结构，减1之后就是0000011111这样的结构，做&amp;运算的话，相当于取hash值除以n的余数。在n等于2的幂次的情况下，这样取余非常高效。 设置数组大小为2的幂次123456789static final int tableSizeFor(int cap) &#123; int n = cap - 1; n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;&#125; 其中cap参数为构造方法传入的map初始大小，cap-1操作是为了防止当cap已经是2的幂的时候，计算出的结果几乎等于原来的2倍。后面的&gt;&gt;&gt;和|的含义为：1.无符号右移1位再做|运算，也就是从最高位起的第一个等于1的数字的下一位设置为1。同理，经过一系列的&gt;&gt;&gt;和|使n等于2的幂减1。2.对n加1,使n等于2的幂。 resize高效的rehash1234567891011121314151617181920Node&lt;K,V&gt; loHead = null, loTail = null;Node&lt;K,V&gt; hiHead = null, hiTail = null;Node&lt;K,V&gt; next;do &#123; next = e.next; if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125;&#125; while ((e = next) != null); 上面的代码片段截取与resize中，其中有一个语句1e.hash &amp; oldCap oldCap是扩容前，数组的大小，我们已经知道e.hash &amp; (oldCap - 1)表示hash % oldCap。那么hash &amp; oldCap是什么意思呢？我们的前提条件是oldCap是2的幂，扩容后的新数组长度是原来的2倍,重新hash后的位置就是hash &amp; (2 * oldCap - 1)相当于 hash &amp; (oldCap &lt;&lt; 1 - 1)相当于(hash &amp; oldCap) + (hash &amp; (oldCap - 1))。所以重hash后原来结点的位置要不不变，要不等于原来的位置加oldCap。 桶内结点树化12if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); 如上，当binCount（桶内的结点树）大于等于TREEIFY_THRESHOLD（默认8）的时候会调用treeifyBin方法。123456789101112131415161718192021final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) &#123; int n, index; Node&lt;K,V&gt; e; // 数组长度小于64，resize if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY) resize(); else if ((e = tab[index = (n - 1) &amp; hash]) != null) &#123; TreeNode&lt;K,V&gt; hd = null, tl = null; do &#123; TreeNode&lt;K,V&gt; p = replacementTreeNode(e, null); if (tl == null) hd = p; else &#123; p.prev = tl; tl.next = p; &#125; tl = p; &#125; while ((e = e.next) != null); if ((tab[index] = hd) != null) hd.treeify(tab); &#125;&#125; 如上，当数组长度小于64，通过resize方法来减少每个桶中的结点数。否则，将桶中的链表转换成红黑树。 实现HashMap123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332import java.util.HashSet;import java.util.Objects;import java.util.Set;/** * 功能描述: 实现一个基于链表法解决冲突问题的散列表 * * @author sunzhiqiang * @create 2019-03-11 */public class MyHashMap&lt;K, V&gt; &#123; /** * 最大容量 */ private static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; /** * 默认初始容量 */ private static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; /** * 默认装载因子 */ private static final float DEFAULT_LOAD_FACTOR = 0.75f; private Node[] table; private int size; private float loadFactor; private int threshold; public MyHashMap(int initialCapacity, float loadFactor) &#123; this.loadFactor = loadFactor; this.threshold = tableSizeFor(initialCapacity); &#125; public MyHashMap(int initialCapacity) &#123; this(initialCapacity, DEFAULT_LOAD_FACTOR); &#125; public MyHashMap() &#123; this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR); &#125; /** * 返回map有多少元素 * * @return */ public int size() &#123; return size; &#125; /** * 返回map是否为空 * * @return */ public boolean isEmpty() &#123; return size == 0; &#125; /** * 获取元素 * * @param key * @return */ public V get(Object key) &#123; Objects.requireNonNull(key); int hash = hash(key); Node&lt;K, V&gt; element = null; // table未初始化或者桶内不存在元素直接返回空 if (table == null || table.length == 0 || (element = table[hash &amp; (table.length - 1)]) == null) &#123; return null; &#125; do &#123; if (element.hash == hash &amp;&amp; (element.key == key || element.key.equals(key))) &#123; return element.value; &#125; element = element.next; &#125; while (element != null); return null; &#125; /** * 判断是否包含key * * @param key * @return */ public boolean containsKey(Object key) &#123; return get(key) != null; &#125; /** * 添加元素 * * @param key * @param value * @return */ public V put(K key, V value) &#123; Objects.requireNonNull(key); // table未初始化的话，先初始化 if (table == null || table.length == 0) &#123; table = new Node[threshold]; threshold = (int) (threshold * loadFactor); &#125; int hash = hash(key); int position; Node&lt;K, V&gt; element = null; // 桶里没有元素，直接插入一个新的结点 if ((element = table[position = hash &amp; (table.length - 1)]) == null) &#123; Node&lt;K, V&gt; node = new Node&lt;&gt;(hash, key, value, null); table[position] = node; size++; return null; &#125; // 桶里有key相同的元素，替换value do &#123; if (hash == element.hash &amp;&amp; (key == element.key || key.equals(element.key))) &#123; V oldValue = element.value; element.value = value; return oldValue; &#125; &#125; while (element != null); // 桶里没有key相同的元素，头插法插入一个新的结点 Node&lt;K, V&gt; head = table[position]; Node&lt;K, V&gt; newHead = new Node&lt;&gt;(hash, key, value, head); table[position] = newHead; size++; if (size &gt; threshold) &#123; table = resize(); &#125; return null; &#125; /** * 删除元素 * * @param key * @return */ public V remove(Object key) &#123; Objects.requireNonNull(key); int hash = hash(key); int position = hash &amp; (table.length - 1); Node&lt;K, V&gt; deleteNode = table[position]; if (deleteNode == null) &#123; return null; &#125; Node&lt;K, V&gt; preNode = null; do &#123; if (hash == deleteNode.hash &amp;&amp; (key == deleteNode.key || key.equals(deleteNode.key))) &#123; if (preNode == null) &#123; table[position] = deleteNode.next; deleteNode.next = null; size--; return deleteNode.value; &#125; else &#123; preNode.next = deleteNode.next; deleteNode.next = null; size--; return deleteNode.value; &#125; &#125; preNode = deleteNode; deleteNode = deleteNode.next; &#125; while (deleteNode != null); return null; &#125; /** * 清空map */ public void clear() &#123; if (table == null || table.length == 0) &#123; return; &#125; for (int i = 0; i &lt; table.length; i++) &#123; table[i] = null; &#125; &#125; /** * 返回一个可遍历的set集合 * * @return */ public Set&lt;Node&lt;K, V&gt;&gt; entrySet() &#123; if (table == null || table.length == 0) &#123; return new HashSet&lt;&gt;(0); &#125; Set&lt;Node&lt;K, V&gt;&gt; set = new HashSet&lt;&gt;(size); for (int i = 0; i &lt; table.length; i++) &#123; Node&lt;K, V&gt; temp = table[i]; while (temp != null) &#123; set.add(temp); temp = temp.next; &#125; &#125; return set; &#125; /** * 扩容 * * @return */ final Node[] resize() &#123; int oldLength = table.length; if (oldLength &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return table; &#125; int newLength = oldLength &lt; (MAXIMUM_CAPACITY &gt;&gt;&gt; 1) ? oldLength &lt;&lt; 1 : MAXIMUM_CAPACITY; Node[] newTable = new Node[newLength]; Node[] oldTable = table; table = newTable; threshold = threshold &lt;&lt; 1; // 重hash for (int i = 0; i &lt; oldLength; i++) &#123; Node&lt;K, V&gt; temp = oldTable[i]; oldTable[i] = null; Node&lt;K, V&gt; unChangeHead = null; Node&lt;K, V&gt; unChangeTail = null; Node&lt;K, V&gt; changeHead = null; Node&lt;K, V&gt; changeTail = null; while (temp != null) &#123; if ((temp.hash &amp; oldLength) == 0) &#123; if (unChangeTail == null) &#123; unChangeHead = temp; &#125; else &#123; unChangeTail.next = temp; &#125; unChangeTail = temp; &#125; else &#123; if (changeTail == null) &#123; changeHead = temp; &#125; else &#123; changeTail.next = temp; &#125; changeTail = temp; &#125; &#125; if (unChangeHead != null) &#123; table[i] = unChangeHead; &#125; if (changeHead != null) &#123; table[i + oldLength] = changeHead; &#125; &#125; return table; &#125; /** * 计算hash值 * * @param key * @return */ static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16); &#125; /** * 计算一个大于cap的最小的2的幂 * * @param cap * @return */ static final int tableSizeFor(int cap) &#123; int n = cap - 1; n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1; &#125; static class Node&lt;K, V&gt; &#123; final int hash; final K key; V value; Node&lt;K, V&gt; next; public Node(int hash, K key, V value, Node next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; &#125;&#125; 我们利用上面源码中的部分设计，实现一个简易的HashMap，实现一些常用的方法。 总结JDK核心类库中有很多精妙的用法，是我们阅读源码的第一手资料，应该培养自己阅读源码的习惯。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法]]></title>
    <url>%2F2019%2F01%2F21%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[概述排序算法是最基础也最有用的算法。为什么说排序算法很有用呢？因为计算机只能处理有规律的东西，排序就是一个无规律到有规律的转换。 分类比较排序 选择排序 插入排序 希尔排序 冒泡排序 归并排序 快速排序 堆排序 非比较排序 计数排序 桶排序 基数排序 时间复杂度稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。不稳定：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。时间复杂度：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。空间复杂度：是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数。 实现冒泡排序冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。1234567891011121314151617181920212223242526272829package cn.com.sunzhiqiang.algorithm.sort.bubble;import cn.com.sunzhiqiang.algorithm.sort.Sort;/** * @author sunzhiqiang * @date 2019/1/8 * @desc 冒泡排序 */public class BubbleSort implements Sort &#123; @Override public int[] sort(int[] waitingSortArray) &#123; for (int i = 1; i &lt; waitingSortArray.length; i++) &#123; for (int j = 0; j &lt; waitingSortArray.length - i; j++) &#123; if (waitingSortArray[j] &gt; waitingSortArray[j + 1]) &#123; int temp = waitingSortArray[j]; waitingSortArray[j] = waitingSortArray[j + 1]; waitingSortArray[j + 1] = temp; &#125; &#125; &#125; return waitingSortArray; &#125;&#125; 选择排序选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。1234567891011121314151617181920212223242526272829303132333435363738package cn.com.sunzhiqiang.algorithm.sort.select;import cn.com.sunzhiqiang.algorithm.sort.Sort;/** * @author sunzhiqiang * @date 2019/1/8 * @desc 选择排序 */public class SelectSort implements Sort &#123; @Override public int[] sort(int[] waitingSortArray) &#123; int minValue = Integer.MAX_VALUE; int minIndex = -1; for (int i = 0; i &lt; waitingSortArray.length - 1; i++) &#123; minValue = Integer.MAX_VALUE; minIndex = -1; for (int j = i; j &lt; waitingSortArray.length; j++) &#123; if (waitingSortArray[j] &lt; minValue) &#123; minValue = waitingSortArray[j]; minIndex = j; &#125; &#125; if (minIndex != i) &#123; int temp = waitingSortArray[i]; waitingSortArray[i] = waitingSortArray[minIndex]; waitingSortArray[minIndex] = temp; &#125; &#125; return waitingSortArray; &#125;&#125; 插入排序插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。12345678910111213141516171819202122232425262728package cn.com.sunzhiqiang.algorithm.sort.insert;import cn.com.sunzhiqiang.algorithm.sort.Sort;/** * @author sunzhiqiang * @date 2019/1/8 * @desc 插入排序 */public class InsertSort implements Sort &#123; @Override public int[] sort(int[] waitingSortArray) &#123; for (int i = 1; i &lt; waitingSortArray.length; i++) &#123; for (int j = i; j &gt;= 1; j--) &#123; if (waitingSortArray[j] &gt;= waitingSortArray[j - 1]) &#123; break; &#125; int temp = waitingSortArray[j]; waitingSortArray[j] = waitingSortArray[j - 1]; waitingSortArray[j - 1] = temp; &#125; &#125; return waitingSortArray; &#125;&#125; 希尔排序1959年Shell发明，第一个突破O(n2)的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。12345678910111213141516171819202122232425262728293031323334package cn.com.sunzhiqiang.algorithm.sort.shell;import cn.com.sunzhiqiang.algorithm.sort.Sort;/** * @author sunzhiqiang * @date 2019/1/11 * @desc 希尔排序 */public class ShellSort implements Sort &#123; @Override public int[] sort(int[] waitingSortArray) &#123; int increment = waitingSortArray.length / 2; while (increment &gt; 0) &#123; for (int i = increment; i &lt; waitingSortArray.length; i++) &#123; for (int j = i; j &gt;= increment; j = j - increment) &#123; if (waitingSortArray[j] &lt; waitingSortArray[j - increment]) &#123; int temp = waitingSortArray[j]; waitingSortArray[j] = waitingSortArray[j - increment]; waitingSortArray[j - increment] = temp; &#125; else &#123; break; &#125; &#125; &#125; increment = increment / 2; &#125; return waitingSortArray; &#125;&#125; 归并排序归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package cn.com.sunzhiqiang.algorithm.sort.merge;import cn.com.sunzhiqiang.algorithm.sort.Sort;import java.util.Arrays;/** * @author sunzhiqiang * @date 2019/1/8 * @desc 归并排序 */public class MergeSort implements Sort &#123; @Override public int[] sort(int[] waitingSortArray) &#123; if (waitingSortArray.length &lt; 2) &#123; return waitingSortArray; &#125;else&#123; int middle = waitingSortArray.length / 2; int[] leftWaitingSortArray = Arrays.copyOfRange(waitingSortArray, 0, middle); int[] rightWaitingSortArray = Arrays.copyOfRange(waitingSortArray, middle, waitingSortArray.length); int[] leftSortedArray = sort(leftWaitingSortArray); int[] rightSortedArray = sort(rightWaitingSortArray); return mergeSortedArray(leftSortedArray, rightSortedArray); &#125; &#125; private int[] mergeSortedArray(int[] leftSortedArray, int[] rightSortedArray) &#123; int[] resultSortedArray = new int[leftSortedArray.length + rightSortedArray.length]; int i = 0; int j = 0; int k = 0; while (i &lt; leftSortedArray.length &amp;&amp; j &lt; rightSortedArray.length) &#123; if (leftSortedArray[i] &lt; rightSortedArray[j]) &#123; resultSortedArray[k++] = leftSortedArray[i++]; &#125; else &#123; resultSortedArray[k++] = rightSortedArray[j++]; &#125; &#125; if (i &lt; leftSortedArray.length) &#123; while (i &lt; leftSortedArray.length) &#123; resultSortedArray[k++] = leftSortedArray[i++]; &#125; &#125; else if (j &lt; rightSortedArray.length) &#123; while (j &lt; rightSortedArray.length) &#123; resultSortedArray[k++] = rightSortedArray[j++]; &#125; &#125; return resultSortedArray; &#125;&#125; 快速排序快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package cn.com.sunzhiqiang.algorithm.sort.quick;import cn.com.sunzhiqiang.algorithm.sort.Sort;/** * @author sunzhiqiang * @date 2019/1/8 * @desc 快速排序 */public class QuickSort implements Sort &#123; @Override public int[] sort(int[] waitingSortArray) &#123; return quickSortImpl(waitingSortArray, 0, waitingSortArray.length - 1); &#125; private int[] quickSortImpl(int[] waitingSortArray, int start, int end) &#123; if (start &gt;= end) &#123; return waitingSortArray; &#125; else &#123; int j = start - 1; for (int i = start; i &lt; end; i++) &#123; if (waitingSortArray[i] &lt;= waitingSortArray[end]) &#123; j++; if (i != j) &#123; int temp = waitingSortArray[i]; waitingSortArray[i] = waitingSortArray[j]; waitingSortArray[j] = temp; &#125; &#125; &#125; j++; int temp = waitingSortArray[end]; waitingSortArray[end] = waitingSortArray[j]; waitingSortArray[j] = temp; quickSortImpl(waitingSortArray, start, j - 1); quickSortImpl(waitingSortArray, j + 1, end); return waitingSortArray; &#125; &#125;&#125; 堆排序堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package cn.com.sunzhiqiang.algorithm.sort.heap;import cn.com.sunzhiqiang.algorithm.sort.Sort;/** * @author sunzhiqiang * @date 2019/1/8 * @desc 堆排序 */public class HeapSort implements Sort &#123; @Override public int[] sort(int[] waitingSortArray) &#123; int[] sortedArray = internalHeapSort(waitingSortArray); return sortedArray; &#125; private int[] internalHeapSort(int[] waitingSortArray) &#123; // 初始化最大堆 for (int i = waitingSortArray.length / 2; i &gt;= 0; i--) &#123; // 调整堆结构 createMaxHeapify(waitingSortArray, waitingSortArray.length, i); &#125; for (int i = 0; i &lt; waitingSortArray.length; i++) &#123; int temp = waitingSortArray[waitingSortArray.length - 1 - i]; waitingSortArray[waitingSortArray.length - 1 - i] = waitingSortArray[0]; waitingSortArray[0] = temp; createMaxHeapify(waitingSortArray, waitingSortArray.length - 1 - i, 0); &#125; return waitingSortArray; &#125; private void createMaxHeapify(int[] waitingSortArray, int heapSize, int i) &#123; int left = 2 * i + 1; int right = 2 * i + 2; boolean exchange = false; int maxIndex = i; if (left &lt; heapSize &amp;&amp; waitingSortArray[maxIndex] &lt; waitingSortArray[left]) &#123; maxIndex = left; exchange = true; &#125; if (right &lt; heapSize &amp;&amp; waitingSortArray[maxIndex] &lt; waitingSortArray[right]) &#123; maxIndex = right; exchange = true; &#125; if (exchange) &#123; int temp = waitingSortArray[i]; waitingSortArray[i] = waitingSortArray[maxIndex]; waitingSortArray[maxIndex] = temp; createMaxHeapify(waitingSortArray, heapSize, maxIndex); &#125; &#125;&#125; 计数排序计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。1234567891011121314151617181920212223242526272829303132333435363738394041424344package cn.com.sunzhiqiang.algorithm.sort.count;import cn.com.sunzhiqiang.algorithm.sort.Sort;/** * 功能描述: 计数排序 * * @author sunzhiqiang * @create 2019-01-14 */public class CountSort implements Sort &#123; @Override public int[] sort(int[] waitingSortArray) &#123; int max = maxValue(waitingSortArray); int[] countArray = new int[max + 1]; for (int i = 0; i &lt; waitingSortArray.length; i++) &#123; countArray[waitingSortArray[i]]++; &#125; int j = 0; for (int i = 0; i &lt; countArray.length; i++) &#123; while (countArray[i] &gt; 0) &#123; waitingSortArray[j++] = i; countArray[i]--; &#125; &#125; return waitingSortArray; &#125; private int maxValue(int[] waitingSortArray) &#123; int max = Integer.MIN_VALUE; for (int i = 0; i &lt; waitingSortArray.length; i++) &#123; if (waitingSortArray[i] &gt; max) &#123; max = waitingSortArray[i]; &#125; &#125; return max; &#125;&#125; 桶排序桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package cn.com.sunzhiqiang.algorithm.sort.bucket;import cn.com.sunzhiqiang.algorithm.sort.Sort;import java.util.Arrays;/** * 功能描述: 桶排序 * * @author sunzhiqiang * @create 2019-01-14 */public class BucketSort implements Sort &#123; private Sort sort; public BucketSort(Sort sort) &#123; this.sort = sort; &#125; @Override public int[] sort(int[] waitingSortArray) &#123; int max = waitingSortArray[0]; int min = waitingSortArray[0]; for (int i = 0; i &lt; waitingSortArray.length; i++) &#123; if (waitingSortArray[i] &gt; max) &#123; max = waitingSortArray[i]; &#125; else if (waitingSortArray[i] &lt; min) &#123; min = waitingSortArray[i]; &#125; &#125; int bucketCount = (max - min) / 5 + 1; int[][] buckets = new int[bucketCount][0]; int index = 0; for (int i = 0; i &lt; waitingSortArray.length; i++) &#123; index = (waitingSortArray[i] - min) / 5; buckets[index] = arrAppend(buckets[index], waitingSortArray[i]); &#125; int arrIndex = 0; for (int i = 0; i &lt; buckets.length; i++) &#123; int[] sortedArray = sort.sort(buckets[i]); if (sortedArray.length &lt;= 0) &#123; continue; &#125; for (int j = 0; j &lt; sortedArray.length; j++) &#123; waitingSortArray[arrIndex++] = sortedArray[j]; &#125; &#125; return waitingSortArray; &#125; private int[] arrAppend(int[] bucket, int value) &#123; bucket = Arrays.copyOf(bucket, bucket.length + 1); bucket[bucket.length - 1] = value; return bucket; &#125;&#125; 基数排序基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package cn.com.sunzhiqiang.algorithm.sort.radix;import cn.com.sunzhiqiang.algorithm.sort.Sort;import java.util.Arrays;/** * 功能描述: 基数排序 * * @author sunzhiqiang * @create 2019-01-15 */public class RadixSort implements Sort &#123; private Sort sort; public RadixSort(Sort sort) &#123; this.sort = sort; &#125; @Override public int[] sort(int[] waitingSortArray) &#123; int max = getMaxValue(waitingSortArray); int maxDigit = getDigit(max); for (int i = 0, dev = 1; i &lt;= maxDigit; i++, dev *= 10) &#123; int[][] buckets = new int[20][0]; for (int j = 0; j &lt; waitingSortArray.length; j++) &#123; int index = waitingSortArray[j] / dev % 10 + 10; buckets[index] = arrAppend(buckets[index], waitingSortArray[j]); &#125; int temp = 0; for (int[] bucket : buckets) &#123; for (int k = 0; k &lt; bucket.length; k++) &#123; waitingSortArray[temp++] = bucket[k]; &#125; &#125; &#125; return waitingSortArray; &#125; private int getDigit(int max) &#123; int maxDigit = 0; while (max != 0) &#123; maxDigit++; max = max / 10; &#125; return maxDigit; &#125; private int getMaxValue(int[] waitingSortArray) &#123; int max = Integer.MIN_VALUE; for (int i = 0; i &lt; waitingSortArray.length; i++) &#123; if (waitingSortArray[i] &gt; max) &#123; max = waitingSortArray[i]; &#125; &#125; return max; &#125; private int[] arrAppend(int[] bucket, int value) &#123; bucket = Arrays.copyOf(bucket, bucket.length + 1); bucket[bucket.length - 1] = value; return bucket; &#125;&#125; 参考文献https://www.cnblogs.com/onepixel/articles/7674659.html]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[访问者模式]]></title>
    <url>%2F2019%2F01%2F13%2F%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[模式的定义表示一个作用于某对象结构中的各个元素的操作。它可以在不改变各个元素的类的前提下定义作用于这些元素的新操作。 代码演示抽象元素1234567891011package cn.com.sunzhiqiang.pattern.visitor;/** * @author sunzhiqiang * @date 2019/1/8 * @desc 抽象元素（电表） */public interface ElectricMeter &#123; void accept(MeterReader meterReader);&#125; 抽象访问者12345678910111213package cn.com.sunzhiqiang.pattern.visitor;import java.math.BigDecimal;/** * @author sunzhiqiang * @date 2019/1/8 * @desc 抽象访问者（抄电表的员工） */public interface MeterReader &#123; BigDecimal calcPrice(ConcreteElectricMeter electricMeter);&#125; 具体元素12345678910111213141516171819202122232425262728package cn.com.sunzhiqiang.pattern.visitor;import java.math.BigDecimal;/** * @author sunzhiqiang * @date 2019/1/8 * @desc 具体元素（具体电表） */public class ConcreteElectricMeter implements ElectricMeter &#123; private BigDecimal meter; public ConcreteElectricMeter(BigDecimal meter) &#123; this.meter = meter; &#125; @Override public void accept(MeterReader meterReader) &#123; BigDecimal totalPrice = meterReader.calcPrice(this); System.out.println(totalPrice); &#125; public BigDecimal getMeter() &#123; return meter; &#125;&#125; 具体访问者123456789101112131415161718192021222324252627282930313233343536373839404142package cn.com.sunzhiqiang.pattern.visitor;import java.math.BigDecimal;/** * @author sunzhiqiang * @date 2019/1/8 * @desc 具体访问者（具体抄表员） */public class ConcreteMeterReader implements MeterReader &#123; private static final int FIRST_LEVEL = 10; private static final int SECOND_LEVEL = 20; private static final int THIRD_LEVEL = 30; private BigDecimal firstLevelPrice = BigDecimal.ONE; private BigDecimal secondLevelPrice = new BigDecimal("1.5"); private BigDecimal thirdLevelPrice = new BigDecimal("2"); @Override public BigDecimal calcPrice(ConcreteElectricMeter electricMeter) &#123; BigDecimal totalPrice = BigDecimal.ZERO; BigDecimal meter = electricMeter.getMeter(); if (meter.compareTo(new BigDecimal(FIRST_LEVEL)) &lt;= 0) &#123; return firstLevelPrice.multiply(meter); &#125; if (meter.compareTo(new BigDecimal(SECOND_LEVEL)) &lt;= 0) &#123; return firstLevelPrice.multiply(new BigDecimal(FIRST_LEVEL)) .add(secondLevelPrice.multiply(meter.subtract(new BigDecimal(FIRST_LEVEL)))); &#125; totalPrice = firstLevelPrice.multiply(new BigDecimal(FIRST_LEVEL)) .add(secondLevelPrice.multiply(new BigDecimal(SECOND_LEVEL).subtract(new BigDecimal(FIRST_LEVEL)))) .add(thirdLevelPrice.multiply(meter.subtract(new BigDecimal(SECOND_LEVEL)))); return totalPrice; &#125;&#125; 抽象元素集合1234567891011121314151617181920212223package cn.com.sunzhiqiang.pattern.visitor;import com.google.common.collect.Sets;import java.util.Set;/** * @author sunzhiqiang * @date 2019/1/8 * @desc 电箱 */public class ElectricBox &#123; private Set&lt;ElectricMeter&gt; electricMeters = Sets.newHashSet(); public void addElectricMeter(ElectricMeter electricMeter) &#123; electricMeters.add(electricMeter); &#125; public Set&lt;ElectricMeter&gt; getElectricMeters() &#123; return electricMeters; &#125;&#125; 客户端类1234567891011121314151617181920212223242526package cn.com.sunzhiqiang.pattern.visitor;import java.math.BigDecimal;/** * @author sunzhiqiang * @date 2019/1/8 * @desc 客户端类 */public class Client &#123; public static void main(String[] args) &#123; ElectricBox electricBox = new ElectricBox(); ConcreteElectricMeter concreteElectricMeter1 = new ConcreteElectricMeter(new BigDecimal("12.5")); ConcreteElectricMeter concreteElectricMeter2 = new ConcreteElectricMeter(new BigDecimal("25")); electricBox.addElectricMeter(concreteElectricMeter1); electricBox.addElectricMeter(concreteElectricMeter2); MeterReader meterReader = new ConcreteMeterReader(); for (ElectricMeter electricMeter : electricBox.getElectricMeters()) &#123; electricMeter.accept(meterReader); &#125; &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[策略模式]]></title>
    <url>%2F2019%2F01%2F13%2F%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[模式的定义定义一系列算法,把它们一个个封装起来,并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。 代码演示抽象策略1234567891011package cn.com.sunzhiqiang.pattern.strategy;/** * @author sunzhiqiang * @date 2019/1/8 * @desc 抽象策略（排序接口） */public interface Sort &#123; int[] sort(int[] waitingSortArray);&#125; 具体策略12345678910111213141516171819202122232425262728293031323334353637383940414243444546package cn.com.sunzhiqiang.pattern.strategy;/** * @author sunzhiqiang * @date 2019/1/8 * @desc 具体策略（快速排序） */public class QuickSort implements Sort &#123; @Override public int[] sort(int[] waitingSortArray) &#123; return quickSortImpl(waitingSortArray, 0, waitingSortArray.length - 1); &#125; private int[] quickSortImpl(int[] waitingSortArray, int start, int end) &#123; if (start &gt;= end) &#123; return waitingSortArray; &#125; else &#123; int j = start - 1; for (int i = start; i &lt; end; i++) &#123; if (waitingSortArray[i] &lt;= waitingSortArray[end]) &#123; j++; if (i != j) &#123; int temp = waitingSortArray[i]; waitingSortArray[i] = waitingSortArray[j]; waitingSortArray[j] = temp; &#125; &#125; &#125; j++; int temp = waitingSortArray[end]; waitingSortArray[end] = waitingSortArray[j]; waitingSortArray[j] = temp; quickSortImpl(waitingSortArray, start, j - 1); quickSortImpl(waitingSortArray, j + 1, end); return waitingSortArray; &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package cn.com.sunzhiqiang.pattern.strategy;import java.util.Arrays;/** * @author sunzhiqiang * @date 2019/1/8 * @desc 具体策略（归并排序） */public class MergeSort implements Sort &#123; @Override public int[] sort(int[] waitingSortArray) &#123; if (waitingSortArray.length &lt; 2) &#123; return waitingSortArray; &#125; else &#123; int middle = waitingSortArray.length / 2; int[] leftWaitingSortArray = Arrays.copyOfRange(waitingSortArray, 0, middle); int[] rightWaitingSortArray = Arrays.copyOfRange(waitingSortArray, middle, waitingSortArray.length); int[] leftSortedArray = sort(leftWaitingSortArray); int[] rightSortedArray = sort(rightWaitingSortArray); return mergeSortedArray(leftSortedArray, rightSortedArray); &#125; &#125; private int[] mergeSortedArray(int[] leftSortedArray, int[] rightSortedArray) &#123; int[] resultSortedArray = new int[leftSortedArray.length + rightSortedArray.length]; int i = 0; int j = 0; int k = 0; while (i &lt; leftSortedArray.length &amp;&amp; j &lt; rightSortedArray.length) &#123; if (leftSortedArray[i] &lt; rightSortedArray[j]) &#123; resultSortedArray[k++] = leftSortedArray[i++]; &#125; else &#123; resultSortedArray[k++] = rightSortedArray[j++]; &#125; &#125; if (i &lt; leftSortedArray.length) &#123; while (i &lt; leftSortedArray.length) &#123; resultSortedArray[k++] = leftSortedArray[i++]; &#125; &#125; else if (j &lt; rightSortedArray.length) &#123; while (j &lt; rightSortedArray.length) &#123; resultSortedArray[k++] = rightSortedArray[j++]; &#125; &#125; return resultSortedArray; &#125;&#125; 上下文123456789101112131415161718192021222324package cn.com.sunzhiqiang.pattern.strategy;/** * @author sunzhiqiang * @date 2019/1/9 * @desc 上下文 */public class SortContext &#123; private Sort sort; public SortContext(Sort sort) &#123; this.sort = sort; &#125; public void setSort(Sort sort) &#123; this.sort = sort; &#125; public int[] sort(int[] waitingSortArray) &#123; return sort.sort(waitingSortArray); &#125;&#125; 客户端类12345678910111213141516171819202122package cn.com.sunzhiqiang.pattern.strategy;import java.util.Arrays;/** * @author sunzhiqiang * @date 2019/1/9 * @desc 客户端类 */public class Client &#123; public static void main(String[] args) &#123; int[] waitingSortArray = new int[]&#123;2, 3, 2, 6, 290, 4234, 1, 7, 3, 21, 45&#125;; SortContext sortContext = new SortContext(new MergeSort()); System.out.println(Arrays.toString(sortContext.sort(waitingSortArray))); sortContext.setSort(new QuickSort()); System.out.println(Arrays.toString(sortContext.sort(waitingSortArray))); &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[观察者模式]]></title>
    <url>%2F2019%2F01%2F13%2F%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[模式的定义定义对象间的一种一对多的依赖关系,当一个对象的状态发生变化时,所有依赖它的对象都得到通知并自动更新。 代码演示自己实现观察者接口1234567891011package cn.com.sunzhiqiang.pattern.observer;/** * @author sunzhiqiang * @date 2019/1/8 * @desc 观察者接口 */interface Observer &#123; void update(Observerable observerable);&#125; 被观察者接口123456789101112131415package cn.com.sunzhiqiang.pattern.observer;/** * @author sunzhiqiang * @date 2019/1/8 * @desc 被观察者接口 */interface Observerable &#123; void addObserver(Observer observer); void removeObserver(Observer observer); void notifyObservers();&#125; 具体被观察者12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package cn.com.sunzhiqiang.pattern.observer;import com.google.common.collect.Lists;import java.util.List;/** * @author sunzhiqiang * @date 2019/1/8 * @desc 具体被观察者 */class Music implements Observerable &#123; List&lt;Observer&gt; observers = Lists.newArrayList(); private String name; public String getName() &#123; return name; &#125; @Override public void addObserver(Observer observer) &#123; if (!observers.contains(observer)) &#123; observers.add(observer); &#125; &#125; @Override public void removeObserver(Observer observer) &#123; observers.remove(observer); &#125; @Override public void notifyObservers() &#123; for (Observer observer : observers) &#123; observer.update(this); &#125; &#125; public void start(String name) &#123; this.name = name; notifyObservers(); &#125;&#125; 具体观察者12345678910111213141516package cn.com.sunzhiqiang.pattern.observer;/** * @author sunzhiqiang * @date 2019/1/8 * @desc 具体观察者（厨师） */class Chef implements Observer &#123; @Override public void update(Observerable observerable) &#123; Music music = (Music) observerable; System.out.println(String.format("厨师听到音乐【%s】开始做饭", music.getName())); &#125;&#125; 12345678910111213141516package cn.com.sunzhiqiang.pattern.observer;/** * @author sunzhiqiang * @date 2019/1/8 * @desc 具体观察者（舞蹈家） */class Dancer implements Observer &#123; @Override public void update(Observerable observerable) &#123; Music music = (Music) observerable; System.out.println(String.format("舞蹈家听到音乐【%s】开始跳舞", music.getName())); &#125;&#125; 客户端类123456789101112131415161718192021package cn.com.sunzhiqiang.pattern.observer;/** * @author sunzhiqiang * @date 2019/1/8 * @desc 客户端类 */public class Client &#123; public static void main(String[] args) &#123; Dancer dancer = new Dancer(); Chef chef = new Chef(); Music music = new Music(); music.addObserver(dancer); music.addObserver(chef); music.start("学猫叫"); &#125;&#125; JDK中的实现具体被观察者12345678910111213141516171819202122232425package cn.com.sunzhiqiang.pattern.observer.jdk;import java.util.Observable;/** * @author sunzhiqiang * @date 2019/1/8 * @desc 具体被观察者 */class Music extends Observable &#123; private String name; public String getName() &#123; return name; &#125; public void start(String name) &#123; this.name = name; setChanged(); notifyObservers(); &#125;&#125; 具体观察者12345678910111213141516171819package cn.com.sunzhiqiang.pattern.observer.jdk;import java.util.Observable;import java.util.Observer;/** * @author sunzhiqiang * @date 2019/1/8 * @desc 具体观察者（厨师） */class Chef implements Observer &#123; @Override public void update(Observable o, Object arg) &#123; Music music = (Music)o; System.out.println(String.format("厨师听到音乐【%s】开始做饭", music.getName())); &#125;&#125; 12345678910111213141516171819package cn.com.sunzhiqiang.pattern.observer.jdk;import java.util.Observable;import java.util.Observer;/** * @author sunzhiqiang * @date 2019/1/8 * @desc 具体观察者（舞蹈家） */class Dancer implements Observer &#123; @Override public void update(Observable o, Object arg) &#123; Music music = (Music) o; System.out.println(String.format("舞蹈家听到音乐【%s】开始跳舞", music.getName())); &#125;&#125; 客户端类123456789101112131415161718192021package cn.com.sunzhiqiang.pattern.observer.jdk;/** * @author sunzhiqiang * @date 2019/1/8 * @desc 客户端类 */public class Client &#123; public static void main(String[] args) &#123; Chef chef = new Chef(); Dancer dancer = new Dancer(); Music music = new Music(); music.addObserver(chef); music.addObserver(dancer); music.start("学猫叫"); &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[装饰模式]]></title>
    <url>%2F2019%2F01%2F13%2F%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[模式的定义动态地给对象添加一些额外的职责。就功能来说装饰模式相比生成子类更为灵活。 代码演示1.抽象元素1234567891011package cn.com.sunzhiqiang.pattern.decorator;/** * @author sunzhiqiang * @date 2019/1/9 * @desc 抽象元素（程序员） */public interface Programmer &#123; void program();&#125; 2.具体元素123456789101112131415package cn.com.sunzhiqiang.pattern.decorator;/** * @author sunzhiqiang * @date 2019/1/9 * @desc 具体元素（服务端程序员） */public class ServerProgrammer implements Programmer &#123; @Override public void program() &#123; System.out.println("服务端编程"); &#125;&#125; 3.装饰者1234567891011121314151617181920212223package cn.com.sunzhiqiang.pattern.decorator;/** * @author sunzhiqiang * @date 2019/1/9 * @desc 装饰者（运维能力） */public class OperationDecorator implements Programmer &#123; private Programmer programmer; public OperationDecorator(Programmer programmer) &#123; this.programmer = programmer; &#125; @Override public void program() &#123; programmer.program(); System.out.println("自动化部署程序"); &#125;&#125; 4.客户端类1234567891011121314151617181920package cn.com.sunzhiqiang.pattern.decorator;/** * @author sunzhiqiang * @date 2019/1/9 * @desc 客户端类 */public class Client &#123; public static void main(String[] args) &#123; Programmer programmer = new ServerProgrammer(); programmer.program(); System.out.println("==================================="); programmer = new OperationDecorator(programmer); programmer.program(); &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fork/Join框架]]></title>
    <url>%2F2019%2F01%2F06%2FFork-Join%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[定义Fork/Join框架Fork/Join框架是Java7提供的一个用于平行执行任务的框架，是一个把大任务割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。 Fork就是把一个大任务切分为若干子任务平行的执行 Join就是合并这些子任务的执行结果，最后得到这个大任务的结果 如图： 工作窃取算法工作窃取（work-stealing）算法是指某个线程从其他队列里窃取任务来执行。那么，为什么需要使用工作窃取算法呢？假如我们需要做一个比较大的任务，可以把这个任务分割为若干互不依赖的子任务，为了减少线程间的竞争，把这些子任务分别放到不同的队列里，并为每个队列创建一个单独的线程来执行队列里的任务，线程和队列一一对应。比如A线程负责处理A队列里的任务。但是，有的线程会先把自己队列里的任务干完，而其他线程对应的队列里还有任务等待处理。干完活的线程与其等着，不如去帮其他线程干活，于是它就去其他线程的队列里窃取一个任务来执行。而在这时它们会访问同一个队列，所以为了减少窃取任务线程和被窃取任务线程之间的竞争，通常会使用双端队列，被窃取任务线程永远从双端队列的头部拿任务执行，而窃取任务的线程永远从双端队列的尾部拿任务执行。如图： 工作窃取算法的优点：充分利用线程进行并行计算，减少了线程间的竞争。 工作窃取算法的缺点：在某些情况下还是存在竞争，比如双端队列里只有一个任务时。并且该算法会消耗了更多的系统资源，比如创建多个线程和多个双端队列。 Fork/Join框架的设计 分割任务。首先我们需要有一个fork类来把大任务分割成子任务，有可能子任务还是很大，所以还需要不停地分割，直到分割出的子任务足够小。 执行任务并合并结果。分割的子任务分别放在双端队列里，然后几个启动线程分别从双端队列里获取任务执行。子任务执行完的结果都统一放在一个队列里，启动一个线程从队列里拿数据，然后合并这些数据。 Fork/Join使用两个类来完成以上两件事情。1.ForkJoinTask：我们要使用ForkJoin框架，必须首先创建一个ForkJoin任务。它提供在任务中执行fork()和join()操作的机制。通常情况下，我们不需要直接继承ForkJoinTask类，只需要继承它的子类，Fork/Join框架提供了以下两个子类。 RecursiveAction：用于没有返回结果的任务。 RecursiveTask：用于有返回结果的任务。 2.ForkJoinPool：ForkJoinTask需要通过ForkJoinPool来执行。任务分割出的子任务会添加到当前工作线程所维护的双端队列中，进入队列的头部。当一个工作线程的队列里暂时没有任务时，它会随机从其他工作线程的队列的尾部获得一个任务。 Fork/Join框架的使用下面是使用Fork/Join框架来实现归并排序的例子：ForkJoinTask的子类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package cn.com.sunzhiqiang.java.fork_join;import java.util.Arrays;import java.util.concurrent.RecursiveTask;/** * 功能描述: 基于fork-join框架的归并排序 * * @author sunzhiqiang * @create 2019-01-06 */public class MergeSortTask extends RecursiveTask&lt;int[]&gt; &#123; private static final int THRESHOLD = 2; private int[] waitingSortArray; public MergeSortTask(int[] waitingSortArray) &#123; this.waitingSortArray = waitingSortArray; &#125; @Override protected int[] compute() &#123; if (waitingSortArray.length &lt; THRESHOLD) &#123; return waitingSortArray; &#125; else &#123; int middle = waitingSortArray.length / 2; MergeSortTask subMergeSortTask1 = new MergeSortTask(Arrays.copyOfRange(waitingSortArray, 0, middle)); MergeSortTask subMergeSortTask2 = new MergeSortTask(Arrays.copyOfRange(waitingSortArray, middle, waitingSortArray.length)); subMergeSortTask1.fork(); subMergeSortTask2.fork(); int[] waitMergeArray1 = subMergeSortTask1.join(); int[] waitMergeArray2 = subMergeSortTask2.join(); return mergeArray(waitMergeArray1, waitMergeArray2); &#125; &#125; private int[] mergeArray(int[] waitMergeArray1, int[] waitMergeArray2) &#123; int[] resultArray = new int[waitMergeArray1.length + waitMergeArray2.length]; int i = 0; int j = 0; int k = 0; while (i &lt; waitMergeArray1.length &amp;&amp; j &lt; waitMergeArray2.length) &#123; if (waitMergeArray1[i] &lt; waitMergeArray2[j]) &#123; resultArray[k++] = waitMergeArray1[i++]; &#125; else &#123; resultArray[k++] = waitMergeArray2[j++]; &#125; &#125; if (i &lt; waitMergeArray1.length) &#123; while (i &lt; waitMergeArray1.length) &#123; resultArray[k++] = waitMergeArray1[i++]; &#125; &#125; else if (j &lt; waitMergeArray2.length) &#123; while (j &lt; waitMergeArray2.length) &#123; resultArray[k++] = waitMergeArray2[j++]; &#125; &#125; return resultArray; &#125;&#125; 客户端类123456789101112131415161718192021222324package cn.com.sunzhiqiang.java.fork_join;import java.util.Arrays;import java.util.concurrent.ForkJoinPool;/** * 功能描述: 客户端类 * * @author sunzhiqiang * @create 2019-01-06 */public class Client &#123; public static void main(String[] args) &#123; int[] array = new int[]&#123;6, 8, 0, 9, 1, 2, 5, 10, 40, 88, 100, 2000, 13&#125;; ForkJoinPool forkJoinPool = ForkJoinPool.commonPool(); MergeSortTask mergeSortTask = new MergeSortTask(array); int[] resultArray = forkJoinPool.invoke(mergeSortTask); System.out.println(Arrays.toString(resultArray)); &#125;&#125; 通过这个例子，我们进一步了解ForkJoinTask,ForkJoinTask与一般任务的主要区别在于它需要实现compute方法，在这个方法里，首先需要判断任务是否足够小，如果足够小就直接执行任务。如果不足够小，就必须分割成两个子任务，每个子任务在调用fork方法时，又会进入compute方法，看看当前子任务是否需要继续分割成子任务，如果不需要继续分割，则执行当前子任务并返回结果。使用join方法会等待子任务执行完并得到其结果。 参考文献《java并发编程的艺术》]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式锁]]></title>
    <url>%2F2019%2F01%2F05%2F%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%2F</url>
    <content type="text"><![CDATA[前言为什么需要分布式锁java提供了synchronized关键字以及JUC包下丰富的锁实现，但这些工具提供的特性全是针对单个JVM的。而当今，依赖单个主机很难应对用户高并发的需求，并且使用单主机也会有单点故障的问题，一旦发生故障，会产生的损失又是非常巨大。所以现在的软件开发大多都是多机部署，这样的话，不同的请求可能会被负载到不同的机器。这个时候，如果使用synchronized和JUC下的工具类来控制共享资源的访问是不能实现原子性和可见性的。所以现在的软件开发离不开分布式锁。 分布式锁实现常见的分布式锁实现有3种方式： 基于数据库排它锁 基于redis 基于Zookeeper 下面介绍一下通过redis实现分布式锁：扩展JUC下的锁接口1234567891011121314151617181920212223package cn.com.sunzhiqiang.distributed.lock;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;/** * 功能描述: 分布式锁接口 * * @author sunzhiqiang * @create 2019-01-05 */public interface DistributedLock extends Lock &#123; @Override default void lockInterruptibly() &#123; throw new DistributedLockException("不支持的方法"); &#125; @Override default Condition newCondition() &#123; throw new DistributedLockException("不支持的方法"); &#125;&#125; 自定义分布式锁异常类123456789101112131415161718package cn.com.sunzhiqiang.distributed.lock;/** * 功能描述: 分布式锁异常 * * @author sunzhiqiang * @create 2019-01-05 */public class DistributedLockException extends RuntimeException &#123; public DistributedLockException(String message) &#123; super(message); &#125; public DistributedLockException(String message, Throwable cause) &#123; super(message, cause); &#125;&#125; 分布式锁实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124package cn.com.sunzhiqiang.distributed.lock;import org.apache.commons.pool2.impl.GenericObjectPoolConfig;import redis.clients.jedis.Jedis;import redis.clients.jedis.JedisPool;import java.util.Collections;import java.util.UUID;import java.util.concurrent.TimeUnit;/** * 功能描述: 基于redis的分布式锁 * * @author sunzhiqiang * @create 2019-01-05 */public class RedisDistributedLock implements DistributedLock &#123; private static final String DEFAULT_LOCK_KEY = "redis_lock_key"; private static final int DEFAULT_TIMEOUT = 5000; private final Jedis jedis; private final String owner; private String lockKey = DEFAULT_LOCK_KEY; private int timeout = DEFAULT_TIMEOUT; public RedisDistributedLock() &#123; jedis = JedisFactory.getJedis(); owner = UUID.randomUUID().toString(); &#125; public RedisDistributedLock(int timeout) &#123; this(); this.timeout = timeout; &#125; public RedisDistributedLock(String lockKey, int timeout) &#123; this(timeout); this.lockKey = lockKey; &#125; @Override public void lock() &#123; while (true) &#123; String result = jedis.set(lockKey, owner, "nx", "px", timeout); if (result != null &amp;&amp; result.equalsIgnoreCase("OK")) &#123; return; &#125; else &#123; try &#123; TimeUnit.MILLISECONDS.sleep(10); &#125; catch (InterruptedException e) &#123; throw new DistributedLockException("锁获取失败", e); &#125; &#125; &#125; &#125; @Override public boolean tryLock() &#123; String result = jedis.set(lockKey, owner, "nx", "px", timeout); if (result != null &amp;&amp; result.equalsIgnoreCase("OK")) &#123; return true; &#125; else &#123; return false; &#125; &#125; @Override public boolean tryLock(long time, TimeUnit unit) &#123; long end = System.currentTimeMillis() + unit.toMillis(time); while (System.currentTimeMillis() &lt; end) &#123; boolean success = tryLock(); if (success) &#123; return true; &#125; else &#123; try &#123; TimeUnit.MILLISECONDS.sleep(10); &#125; catch (InterruptedException e) &#123; throw new DistributedLockException("锁获取失败", e); &#125; &#125; &#125; return false; &#125; @Override public void unlock() &#123; jedis.eval("if redis.call('get', KEYS[1]) == ARGV[1] " + "then return redis.call('del',KEYS[1]) else return 0 end", Collections.singletonList(lockKey), Collections.singletonList(owner)); &#125; private static class JedisFactory &#123; private JedisPool jedisPool; private JedisFactory() &#123; GenericObjectPoolConfig poolConfig = new GenericObjectPoolConfig(); poolConfig.setMaxIdle(10); poolConfig.setMaxTotal(30); jedisPool = new JedisPool(poolConfig, "47.105.76.62", 6379); &#125; static JedisFactory getInstance() &#123; return JedisFactoryHolder.JEDIS_FACTORY; &#125; static Jedis getJedis() &#123; return getInstance().jedisPool.getResource(); &#125; static class JedisFactoryHolder &#123; private static final JedisFactory JEDIS_FACTORY = new JedisFactory(); &#125; &#125;&#125; 客户端测试类123456789101112131415161718192021222324252627282930package cn.com.sunzhiqiang.distributed.lock;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;/** * 功能描述: 客户端类 * * @author sunzhiqiang * @create 2019-01-05 */public class Client &#123; public static void main(String[] args) &#123; ExecutorService threadPool = Executors.newCachedThreadPool(); for (int i = 0; i &lt; 10; i++) &#123; threadPool.submit(() -&gt; &#123; DistributedLock distributedLock = new RedisDistributedLock(5000); distributedLock.lock(); try &#123; System.out.println(String.format("线程%s执行开始", Thread.currentThread().getId())); System.out.println(String.format("线程%s执行结束", Thread.currentThread().getId())); &#125; finally &#123; distributedLock.unlock(); &#125; &#125;); &#125; &#125;&#125;]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[happens-before]]></title>
    <url>%2F2018%2F12%2F23%2Fhappens-before%2F</url>
    <content type="text"><![CDATA[定义happens-before的概念最初由Leslie Lamport在其一篇影响深远的论文（《Time,Clocks and the Ordering of Events in a Distributed System》）中提出。Leslie Lamport使用happens-before来定义分布式系统中事件之间的偏序关系（partial ordering）。Leslie Lamport在这篇论文中给出了一个分布式算法，该算法可以将该偏序关系扩展为某种全序关系。JSR-133使用happens-before的概念来指定两个操作之间的执行顺序。由于这两个操作可以在一个线程之内，也可以是在不同线程之间。因此，JMM可以通过happens-before关系向程序员提供跨线程的内存可见性保证（如果A线程的写操作a与B线程的读操作b之间存在happens-before关系，尽管a操作和b操作在不同的线程中执行，但JMM向程序员保证a操作将对b操作可见）。《JSR-133:Java Memory Model and Thread Specification》对happens-before关系的定义如下： 如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。 两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照happens-before关系指定的顺序来执行。如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么这种重排序并不非法（也就是说，JMM允许这种重排序）。 上面的1是JMM对程序员的承诺。从程序员的角度来说，可以这样理解happens-before关系：如果A happens-before B ,那么Java内存模型将向程序员保证——A操作的结果将对B可见，且A的执行顺序排在B之前。注意，这只是Java内存模型向程序员做出的保证！上面的2是JMM对编译器和处理器重排序的约束原则。正如前面所言，JMM其实是在遵循一个基本原则：只要不改变程序的执行结果（指的是单线程程序和正确同步的多线程程序），编译器和处理器怎么优化都行。JMM这么做的原因是：程序员对于这两个操作是否真的被重排序并不关心，程序员关心的是程序执行时的语义不能被改变（即执行结果不能被改变）。因此，happens-before关系本质上和as-if-serial语义是一回事。 as-if-serial语义保证单线程内程序的执行结果不被改变，happens-before关系保证正确同步的多线程程序的执行结果不被改变。 as-if-serial语义给编写单线程程序的程序员创造了一个幻境：单线程程序是按程序的顺序来执行的。happens-before关系给编写正确同步的多线程程序的程序员创造了一个幻境：正确同步的多线程程序是按happens-before指定的顺序来执行的。 as-if-serial和happens-before这么做的目的，都是为了在不改变程序执行结果的前提下，尽可能地提高程序执行的并行度。 happens-before规则《JSR-133:Java Memory Model and Thread Specification》定义了如下happens-before规则。 程序顺序规则：一个线程中的每个操作happens-before于该线程中的任意后续操作。 监视器锁规则：对一个锁的解锁，happens-before与随后对这个锁的加锁。 volatile变量规则：对一个volatile域的写，happens-before与任意后续对这个volatile域的读。 传递性：如果A happens-before B,且B happens-before C,那么A happens-before C。 start()规则：如果线程A执行操作ThreadB.start()(启动线程B)，那么A线程的ThreadB.start()操作happens-before于线程B中的任意操作。 join()规则：如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回。 参考文献《Java并发编程的艺术》]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[volatile]]></title>
    <url>%2F2018%2F12%2F16%2Fvolatile%2F</url>
    <content type="text"><![CDATA[定义java语言规范第3版中对volatile的定义如下：java编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致地更新，线程应该确保通过排它锁单独获得这个变量。Java语言提供了volatile,在某些情况下比锁要更加方便。如果一个字段被声明成volatile,Java线程内存模型确保所有线程看到这个变量的值是一致的。 解析保证线程安全的3个特性： 原子性 可见性 有序性 根据上面的定义我们可以明白volatile是比锁更轻量级的同步原语，它保证了内存可见性（定义中没有提到volatile对有序性的影响，实际上volatile会影响重排序，对有序性也有一定作用）。JMM内存模型图如图，为了提高处理速度，处理器不直接和内存进行通信，而是先将系统的数据读到内部缓存（L1，L2，寄存器或其他）后再进行操作，但操作完不知道何时会写到内存。所以多线程共享变量会产生可见性问题。volatile是如何实现可见性的？如果对声明了volatile的变量进行写操作，JVM就会向处理器发送一个Lock前缀的指令，将这个变量所在缓存行的数据写回到系统内存。但是，就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题。所以，在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。总结一下，其实是以下两点： 将当前处理器缓存行的数据写回到系统内存。 这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效。 其实要保证内存的可见性，还需要另一个保证，就是一个线程对volatile变量的写要先发生于另一个变量对该volatile变量的读取。这是happens-before的其中一条规则。通过这个规则保证了对volatile变量的修改对于其后所有读取该变量的线程都可见。 参考文献《Java并发编程的艺术》]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阻塞队列]]></title>
    <url>%2F2018%2F12%2F02%2F%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[定义阻塞队列是一个支持两个附加操作的队列。这两个附加的操作支持阻塞的插入和移除方法。 支持阻塞的插入方法：意思是当队列满时，队列会阻塞插入元素的线程，直到队列不满。 支持阻塞的移除方法：意思是在队列为空时，队列会阻塞移除元素的线程，直到队列不空。 分类java里提供了7个阻塞队列，如下： ArrayBlockingQueue:一个由数组结构组成的有界阻塞队列。 LinkedBlockingQueue:一个由链表结构组成的有界阻塞队列。 PriorityBlockingQueue:一个支持优先级排序的无界阻塞队列。 DelayQueue:一个使用优先级队列实现的无界阻塞队列。 SynchronousQueue:一个不存储元素的阻塞队列。 LinkedTransferQueue:一个由链表结构组成的无界阻塞队列。 LinkedBlockingDeque:一个由链表结构组成的双向阻塞队列。 具体介绍ArrayBlockingQueueArrayBlockingQueue是一个用数组实现的有界阻塞队列。此队列按照先进先出（FIFO）的原则对元素进行排序。 LinkedBlockingQueueLinkedBlockingQueue是一个用链表实现的有界阻塞队列。此队列的默认和最大长度为Integer.MAX_VALUE。此队列按照先进先出的原则对元素进行排序。 PriorityBlockingQueuePriorityBlockingQueue是一个支持优先级的无界阻塞队列。默认情况下元素采取自然顺序升序排列。也可以自定义类实现compareTo()方法来指定元素排序规则，或者初始化PriorityBlockingQueue时，指定构造参数Comparator来对元素进行排序。需要注意的是不能保证同优先级元素的顺序。 DelayQueueDelayQueue是一个支持延时获取元素的无界阻塞队列。队列使用PriorityQueue来实现。队列中的元素必须实现Delayed接口，在创建元素时可以指定多久才能从队列中获取当前元素。只有在延迟期满时才能从队列中提取元素。DelayQueue非常有用，可以将DelayQueue运用在以下应用场景。 缓存系统的设计：可以用DelayQueue保存缓存元素的有效期，使用一个线程循环查询DelayQueue,一旦能从DelayQueue中获取元素时，表示缓存有效期到了。 定时任务调度：使用DelayQueue保存当天将会执行的任务和执行时间，一旦从DelayQueue中获取到任务就开始执行，比如TimerQueue就是使用DelayQueue实现的。 SynchronousQueueSynchronousQueue是一个不存储元素的阻塞队列。每一个put操作必须等待一个take操作，否则不能继续添加元素。SynchronousQueue可以看成是一个传球手，负责把生产者线程处理的数据直接传递给消费者线程。队列本身并不存储任何元素，非常适合传递性场景。SynchronousQueue的吞吐量高于LinkedBlockingQueue和ArrayBlockingQueue。 LinkedTransferQueueLinkedTransferQueue是一个由链表结构组成的无界阻塞TransferQueue队列。相对于其他阻塞队列，LinkedTransferQueue多了tryTransfer和transfer方法。 LinkedBlockingDequeLinkedBlockingDeque是一个由链表结构组成的双向阻塞队列。所谓双向队列指的是可以从队列的两端插入和移出元素。双向队列因为多了一个操作队列的入口，在多线程同时入队时，也就减少了一半的竞争。相比其他的阻塞队列，LinkedBlockingDeque多了addFirst、addLast、OfferFirst、offerLast、peekFirst和peekLast等方法，以First单词结尾的方法，表示插入、获取（peek）或移除双端队列的第一个元素。以Last单词结尾的方法，表示插入、获取或移除双端队列的最后一个元素。另外，插入方法add等同于addLast,移除方法remove等效于removeFirst。但是take方法却等同于takeFirst,不知道是不是JDK的bug,使用时还是用带有First和Last后缀的方法更清楚。在初始化LinkedBlockingDeque时可以设置容量防止其过度膨胀。另外，双向阻塞队列可以运用在“工作窃取”模式中。 参考文献《Java并发编程的艺术》]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[中介者模式]]></title>
    <url>%2F2018%2F11%2F12%2F%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[概述用一个中介对象来封装一系列的对象交互.中介者使各对象不需要显示地相互引用,从而使其耦合松散,而且可以独立地改变它们之间的交互. 代码演示中介者1234567891011121314151617181920import java.util.concurrent.ConcurrentHashMap;/** * 功能描述: 中介者模式-中介者 * * @author sunzhiqiang * @create 2018-11-12 */public class ServiceMediator &#123; private ConcurrentHashMap&lt;String, Service&gt; register = new ConcurrentHashMap&lt;&gt;(); public void registered(Service service) &#123; register.put(service.getName(), service); &#125; public ConcurrentHashMap&lt;String, Service&gt; getRegister()&#123; return register; &#125;&#125; 抽象服务12345678910111213141516import java.util.List;/** * 功能描述: 中介者模式-抽象的服务 * * @author sunzhiqiang * @create 2018-11-12 */public interface Service &#123; String getName(); String service(); List&lt;Service&gt; getRemoteServices();&#125; 具体服务123456789101112131415161718192021222324252627282930313233343536373839import java.util.List;import java.util.stream.Collectors;/** * 功能描述: 中介者模式-具体服务 * * @author sunzhiqiang * @create 2018-11-12 */public class ConcreteServiceA implements Service &#123; private final ServiceMediator serviceMediator; private String name; public ConcreteServiceA(ServiceMediator serviceMediator) &#123; this.serviceMediator = serviceMediator; name = ConcreteServiceA.class.getName(); serviceMediator.registered(this); &#125; @Override public String getName() &#123; return name; &#125; @Override public String service() &#123; return name + "提供的服务"; &#125; @Override public List&lt;Service&gt; getRemoteServices() &#123; List&lt;Service&gt; services = serviceMediator.getRegister().entrySet().stream() .map(e -&gt; e.getValue()).collect(Collectors.toList()); return services; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839import java.util.List;import java.util.stream.Collectors;/** * 功能描述: 中介者模式-具体服务 * * @author sunzhiqiang * @create 2018-11-12 */public class ConcreteServiceB implements Service &#123; private final ServiceMediator serviceMediator; private String name; public ConcreteServiceB(ServiceMediator serviceMediator) &#123; this.serviceMediator = serviceMediator; name = ConcreteServiceB.class.getName(); serviceMediator.registered(this); &#125; @Override public String getName() &#123; return name; &#125; @Override public String service() &#123; return name + "提供的服务"; &#125; @Override public List&lt;Service&gt; getRemoteServices() &#123; List&lt;Service&gt; services = serviceMediator.getRegister().entrySet().stream() .map(e -&gt; e.getValue()).collect(Collectors.toList()); return services; &#125;&#125; 客户端类123456789101112131415161718192021222324import java.util.List;/** * 功能描述: 客户端类 * * @author sunzhiqiang * @create 2018-11-12 */public class Client &#123; public static void main(String[] args) &#123; ServiceMediator serviceMediator = new ServiceMediator(); Service serviceA = new ConcreteServiceA(serviceMediator); Service serviceB = new ConcreteServiceB(serviceMediator); System.out.println("服务A提供的服务" + serviceA.service()); List&lt;Service&gt; services = serviceA.getRemoteServices(); System.out.println("服务A能获取的服务列表"); for (Service service : services) &#123; System.out.println(service.service()); &#125; &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AQS]]></title>
    <url>%2F2018%2F11%2F11%2FAQS%2F</url>
    <content type="text"><![CDATA[概述 JUC包下提供了大量的同步工具类来帮助我们更好的使用多线程进行并发编程， 例如：ReentrantLock，ReentrantReadWriteLock，CountDownLatch，Semaphore等。 而这些方便的同步器工具类的基础框架就是AQS(AbstractQueuedSynchronizer),学习AQS对更好的理解常用的同步器工具类有很大帮助。 原理 AQS是一个模板类，是用来构建锁和其他同步组件的基础框架。 它的实现主要依赖一个volatile修饰int成员变量来表示同步状态，以及通过一个FIFO队列构成同步队列。 状态的更新使用getState,setState以及compareAndSetState这三个方法。 同步器既支持独占式获取同步状态，也可以支持共享式获取同步状态，这样就可以方便的实现不同类型的同步组件。 它的子类通过重写AQS的几个protected修饰的用来改变同步状态的方法，具体排队和阻塞机制由AQS实现， 它简化了锁的实现方式，屏蔽了同步状态的管理，线程的排队，等待和唤醒等底层操作。锁和同步器很好的隔离了使用者和实现者所需关注的领域。 子类需要重新的方法 成员变量1234567891011121314151617181920212223242526272829303132333435private static final long serialVersionUID = 7373984972572414691L; // 同步队列的头指针和尾指针private transient volatile Node head;private transient volatile Node tail;// 同步状态private volatile int state;// 当使用限时版本的api时，如果时间小于该值，不进入等待状态static final long spinForTimeoutThreshold = 1000L; // Unsafe类对象，为了实现CAS使用private static final Unsafe unsafe = Unsafe.getUnsafe();private static final long stateOffset;private static final long headOffset;private static final long tailOffset;private static final long waitStatusOffset;private static final long nextOffset;static &#123; try &#123; stateOffset = unsafe.objectFieldOffset (AbstractQueuedSynchronizer.class.getDeclaredField("state")); headOffset = unsafe.objectFieldOffset (AbstractQueuedSynchronizer.class.getDeclaredField("head")); tailOffset = unsafe.objectFieldOffset (AbstractQueuedSynchronizer.class.getDeclaredField("tail")); waitStatusOffset = unsafe.objectFieldOffset (Node.class.getDeclaredField("waitStatus")); nextOffset = unsafe.objectFieldOffset (Node.class.getDeclaredField("next")); &#125; catch (Exception ex) &#123; throw new Error(ex); &#125;&#125; 从上面的成员变量可以看出，核心的成员变量有3个：state、head、tailstate用来表示同步状态head、tail分别是AQS维护的同步队列的头指针和尾指针。 同步队列结构队列中的每个结点的结构为如下代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758static final class Node &#123; // 共享模式 static final Node SHARED = new Node(); // 独占模式 static final Node EXCLUSIVE = null; // 线程已被取消 static final int CANCELLED = 1; // 当前线程的后继线程需要被unpark(唤醒) static final int SIGNAL = -1; // 线程(处在Condition休眠状态)在等待Condition唤醒 static final int CONDITION = -2; // 共享模式下，确保向后面的结点传播 static final int PROPAGATE = -3; // 等待状态 volatile int waitStatus; // 前驱结点 volatile Node prev; // 后继结点 volatile Node next; // 等待获取锁的线程 volatile Thread thread; // 等待队列中的下一个节点 Node nextWaiter; // 是不是共享锁 final boolean isShared() &#123; return nextWaiter == SHARED; &#125; // 获取前驱结点 final Node predecessor() throws NullPointerException &#123; Node p = prev; if (p == null) throw new NullPointerException(); else return p; &#125; Node() &#123; // Used to establish initial head or SHARED marker &#125; Node(Thread thread, Node mode) &#123; // Used by addWaiter this.nextWaiter = mode; this.thread = thread; &#125; Node(Thread thread, int waitStatus) &#123; // Used by Condition this.waitStatus = waitStatus; this.thread = thread; &#125;&#125; 独占模式独占模式相关的api1 不响应中断的获取public final void acquire(int arg);12345public final void acquire(int arg) &#123; if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt();&#125; 先获取同步状态，该方法为protected修饰，需要子类重写，调用子类的获取锁的方法123protected boolean tryAcquire(int arg) &#123; throw new UnsupportedOperationException();&#125; 获取同步状态失败，增加一个结点到等待队列里1234567891011121314151617private Node addWaiter(Node mode) &#123; // 根据mode的值决定生成的是独占结点还是共享结点，这里新加入的结点waitStatus应该为0 Node node = new Node(Thread.currentThread(), mode); // 把上一步生成的结点插入队尾 Node pred = tail; // 队尾不为空，利用CAS修改队尾为新加入的结点 if (pred != null) &#123; node.prev = pred; if (compareAndSetTail(pred, node)) &#123; pred.next = node; return node; &#125; &#125; // 队尾为空或者CAS插入失败 enq(node); return node;&#125; 将新加的结点插入队列12345678910111213141516private Node enq(final Node node) &#123; for (;;) &#123; Node t = tail; if (t == null) &#123; // 初始化等待队列 if (compareAndSetHead(new Node())) tail = head; &#125; else &#123; // 使用CAS将队尾更新为新结点 node.prev = t; if (compareAndSetTail(t, node)) &#123; t.next = node; return t; &#125; &#125; &#125;&#125; 排队获取同步状态1234567891011121314151617181920212223final boolean acquireQueued(final Node node, int arg) &#123; boolean failed = true; try &#123; boolean interrupted = false; for (;;) &#123; // 获取当前结点的前驱结点 final Node p = node.predecessor(); // 如果当前结点是头结点的下一个结点，并且获取锁成功，设置当前结点为新的头结点，原来的头结点出队 if (p == head &amp;&amp; tryAcquire(arg)) &#123; setHead(node); p.next = null; // help GC failed = false; return interrupted; &#125; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125; 重新设置头结点12345private void setHead(Node node) &#123; head = node; node.thread = null; node.prev = null; &#125; 判断是否应该挂起线程12345678910111213141516171819202122private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123; int ws = pred.waitStatus; // 如果前驱结点的状态为SIGNAL（表明当前驱结点释放锁时会恢复当前结点）， // 返回true调用parkAndCheckInterrupt方法挂起当前线程 if (ws == Node.SIGNAL) return true; // 等待状态大于0只有一种状态为取消状态 if (ws &gt; 0) &#123; do &#123; // 向前遍历，找前边第一个状态不是取消的结点 node.prev = pred = pred.prev; &#125; while (pred.waitStatus &gt; 0); pred.next = node; &#125; else &#123; // 将前驱结点的等待状态更新为SIGNAL，下一次循环的时候返回true,挂起当前线程 compareAndSetWaitStatus(pred, ws, Node.SIGNAL); &#125; return false;&#125; 挂起线程1234private final boolean parkAndCheckInterrupt() &#123; LockSupport.park(this); return Thread.interrupted();&#125; 恢复中断状态123static void selfInterrupt() &#123; Thread.currentThread().interrupt();&#125; 流程如下: 2 响应中断的获取public final void acquireInterruptibly(int arg) throws InterruptedException;1234567public final void acquireInterruptibly(int arg) throws InterruptedException &#123; if (Thread.interrupted()) throw new InterruptedException(); if (!tryAcquire(arg)) doAcquireInterruptibly(arg);&#125; 获取同步状态,获取失败调用doAcquireInterruptibly方法. 12345678910111213141516171819202122private void doAcquireInterruptibly(int arg) throws InterruptedException &#123; final Node node = addWaiter(Node.EXCLUSIVE); boolean failed = true; try &#123; for (;;) &#123; final Node p = node.predecessor(); if (p == head &amp;&amp; tryAcquire(arg)) &#123; setHead(node); p.next = null; // help GC failed = false; return; &#125; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) throw new InterruptedException(); &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125; 方法与acquire流程差不多,唯一的区别是,acquire只设置中断标志,而这个方法会抛出中断异常. 3 响应中断的限时获取public final boolean tryAcquireNanos(int arg, long nanosTimeout) throws InterruptedException;1234567public final boolean tryAcquireNanos(int arg, long nanosTimeout) throws InterruptedException &#123; if (Thread.interrupted()) throw new InterruptedException(); return tryAcquire(arg) || doAcquireNanos(arg, nanosTimeout);&#125; 获取同步状态失败,调用doAcquireNanos方法. 1234567891011121314151617181920212223242526272829303132333435private boolean doAcquireNanos(int arg, long nanosTimeout) throws InterruptedException &#123; // 超时时间小于等于0直接返回 if (nanosTimeout &lt;= 0L) return false; // 计算什么时候超时 final long deadline = System.nanoTime() + nanosTimeout; final Node node = addWaiter(Node.EXCLUSIVE); boolean failed = true; try &#123; for (;;) &#123; final Node p = node.predecessor(); if (p == head &amp;&amp; tryAcquire(arg)) &#123; setHead(node); p.next = null; // help GC failed = false; return true; &#125; nanosTimeout = deadline - System.nanoTime(); // 超时直接返回 if (nanosTimeout &lt;= 0L) return false; // 没超时时,挂起线程 if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; nanosTimeout &gt; spinForTimeoutThreshold) LockSupport.parkNanos(this, nanosTimeout); // 响应中断 if (Thread.interrupted()) throw new InterruptedException(); &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125; 大致流程也和acquire差不多,增加了响应中断和超时返回. 4 释放public final boolean release(int arg);123456789public final boolean release(int arg) &#123; if (tryRelease(arg)) &#123; Node h = head; if (h != null &amp;&amp; h.waitStatus != 0) unparkSuccessor(h); return true; &#125; return false;&#125; 释放同步状态失败直接返回,释放成功判断头结点的等待状态,不等于0调用unparkSuccessor方法. 123protected boolean tryRelease(int arg) &#123; throw new UnsupportedOperationException();&#125; 1234567891011121314151617181920private void unparkSuccessor(Node node) &#123; // 更新头结点的状态为0 int ws = node.waitStatus; if (ws &lt; 0) compareAndSetWaitStatus(node, ws, 0); // 查找头结点后第一个状态不是取消的结点 Node s = node.next; if (s == null || s.waitStatus &gt; 0) &#123; s = null; for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev) if (t.waitStatus &lt;= 0) s = t; &#125; // 头结点后存在没有取消的结点,唤醒该结点里的线程. if (s != null) LockSupport.unpark(s.thread);&#125; 共享模式共享模式相关的api1 不响应中断的获取public final void acquireShared(int arg);1234public final void acquireShared(int arg) &#123; if (tryAcquireShared(arg) &lt; 0) doAcquireShared(arg);&#125; 获取同步状态,返回值大于等于0获取成功,获取失败调用doAcquireShared方法.1234567891011121314151617181920212223242526272829private void doAcquireShared(int arg) &#123; // 增加一个结点到等待队列中 final Node node = addWaiter(Node.SHARED); boolean failed = true; try &#123; boolean interrupted = false; for (;;) &#123; // 获取先驱结点,先驱结点是头结点,并且获取同步状态成功 final Node p = node.predecessor(); if (p == head) &#123; int r = tryAcquireShared(arg); if (r &gt;= 0) &#123; setHeadAndPropagate(node, r); // 将head指向自己，还有剩余资源可以再唤醒之后的线程 p.next = null; // help GC if (interrupted) selfInterrupt(); failed = false; return; &#125; &#125; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125; 1234567891011private void setHeadAndPropagate(Node node, int propagate) &#123; Node h = head; // Record old head for check below setHead(node); // 如果还有剩余资源，继续唤醒后面的线程 if (propagate &gt; 0 || h == null || h.waitStatus &lt; 0 || (h = head) == null || h.waitStatus &lt; 0) &#123; Node s = node.next; if (s == null || s.isShared()) doReleaseShared(); &#125;&#125; 123456789101112131415161718private void doReleaseShared() &#123; for (;;) &#123; Node h = head; if (h != null &amp;&amp; h != tail) &#123; int ws = h.waitStatus; if (ws == Node.SIGNAL) &#123; if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0)) continue; // loop to recheck cases unparkSuccessor(h); // 唤醒后继 &#125; else if (ws == 0 &amp;&amp; !compareAndSetWaitStatus(h, 0, Node.PROPAGATE)) continue; // loop on failed CAS &#125; if (h == head) // loop if head changed break; &#125;&#125; 2 响应中断的获取public final void acquireSharedInterruptibly(int arg) throws InterruptedException;相应中断的共享获取与acquireShared大致相同,只是由原来的修改中断状态改成抛出中断异常. 3 响应中断的限时获取public final boolean tryAcquireSharedNanos(int arg, long nanosTimeout) throws InterruptedException;与独占模式的相应API差不多,这里省略. 4 释放public final boolean releaseShared(int arg);1234567public final boolean releaseShared(int arg) &#123; if (tryReleaseShared(arg)) &#123; doReleaseShared(); return true; &#125; return false;&#125; 释放同步状态成功,调用doReleaseShared方法.]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[命令模式]]></title>
    <url>%2F2018%2F11%2F11%2F%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[概述将一个请求封装为一个对象,从而使用户可用不同的请求对客户进行参数化;对请求排队或记录请求日志,以及支持可撤销的操作. 代码演示 抽象命令 12345678910/** * 功能描述: 命令模式-抽象命令 * * @author sunzhiqiang * @create 2018-11-11 */public interface Command &#123; String execute();&#125; 具体命令 1234567891011121314151617181920/** * 功能描述: 命令模式-具体命令 * * @author sunzhiqiang * @create 2018-11-11 */public class ConcreteCommand implements Command &#123; private Receiver receiver; public ConcreteCommand(Receiver receiver) &#123; this.receiver = receiver; &#125; @Override public String execute() &#123; return receiver.doCommand(); &#125;&#125; 请求处理者 12345678910111213/** * 功能描述: 命令模式-请求处理者 * * @author sunzhiqiang * @create 2018-11-11 */public class Receiver &#123; public String doCommand() &#123; return "命令被执行"; &#125;&#125; 请求发起人 12345678910111213141516171819/** * 功能描述: 命令模式-请求发起人 * * @author sunzhiqiang * @create 2018-11-11 */public class Invoker &#123; private Command command; public Invoker(Command command) &#123; this.command = command; &#125; public String invoke() &#123; return command.execute(); &#125;&#125; 客户端类 123456789101112131415161718/** * 功能描述: 命令模式-客户端 * * @author sunzhiqiang * @create 2018-11-11 */public class Client &#123; public static void main(String[] args) &#123; Receiver receiver = new Receiver(); Command command = new ConcreteCommand(receiver); Invoker invoker = new Invoker(command); String invokeResult = invoker.invoke(); System.out.println(invokeResult); &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Exchanger]]></title>
    <url>%2F2018%2F11%2F11%2FExchanger%2F</url>
    <content type="text"><![CDATA[引言JUC包下提供了4种常用的同步器： CyclicBarrier（循环屏障） CountDownLatch（倒计时器） Semaphore（信号量） Exchanger（交换者） CyclicBarrier:https://sunzhiqiang.com.cn/2018/09/16/CyclicBarrier%E7%B1%BB/CountDownLatch:https://sunzhiqiang.com.cn/2018/11/04/%E7%BA%BF%E7%A8%8B%E6%B1%A0-2-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BD%BF%E7%94%A8/Semaphore:https://sunzhiqiang.com.cn/2018/10/28/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/上面的3种都在其它地方介绍过，下面主要看一下Exchanger的使用。 Exchanger使用Exchanger是一个用于线程间协作的工具类。Exchanger用于进行线程间的数据交换。它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。这两个线程通过通过exchange方法交换数据，如果第一个线程先执行exchange()方法，它会一直等待第二个线程也执行exchange()方法，当两个线程都到达同步点时，这两个线程就可以交换数据，将本线程生产出来的数据传递给对方。下面以代码的方式展示一下Exchanger的使用：123456789101112131415161718192021222324252627282930313233343536import java.util.concurrent.CountDownLatch;import java.util.concurrent.Exchanger;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;/** * 功能描述: Exchanger学习 * * @author sunzhiqiang * @create 2018-11-11 */public class ExchangerStudy &#123; private static Exchanger&lt;String&gt; exchanger = new Exchanger&lt;&gt;(); private static ExecutorService threadPool = Executors.newFixedThreadPool(2); public static void main(String[] args) throws InterruptedException &#123; CountDownLatch countDownLatch = new CountDownLatch(2); for (int i = 0; i &lt; 2; i++) &#123; threadPool.submit(() -&gt; &#123; String threadName = Thread.currentThread().getName(); Long threadId = Thread.currentThread().getId(); System.out.println(threadId + "我是线程：" + threadName); String dataFromOtherThread = exchanger.exchange(threadName); System.out.println(threadId + "它是线程：" + dataFromOtherThread); countDownLatch.countDown(); return null; &#125;); &#125; countDownLatch.await(); System.out.println("Exchanger交换2个线程的数据。"); &#125;&#125;]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ReentrantReadWriteLock]]></title>
    <url>%2F2018%2F11%2F10%2FReentrantReadWriteLock%2F</url>
    <content type="text"><![CDATA[引言使用synchronized和ReentrantLock都可以实现多线程同步访问，但两者都是互斥访问，对于读多写少的场景，难免会降低并发性，为此java5中新增了ReentrantReadWriteLock。ReentrantReadWriteLock分为读锁和写锁，读锁可以允许多线程同时访问，写锁是独占锁。 使用 读锁共享访问，写锁互斥访问下面是一个使用读写锁的小代码段，通过这个代码段也可以看出读锁可以共享访问，写锁必须互斥访问。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081import java.util.Random;import java.util.concurrent.*;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantReadWriteLock;/** * 功能描述: 读写锁学习 * * @author sunzhiqiang * @create 2018-11-10 */public class ReentrantReadWriteLockStudy &#123; // 模拟的多线程需要共享的数据 private int data = 1; private Random random = new Random(); // 读写锁 private ReentrantReadWriteLock readWriteLock = new ReentrantReadWriteLock(); private Lock readLock = readWriteLock.readLock(); private Lock writeLock = readWriteLock.writeLock(); public void load() throws InterruptedException &#123; readLock.lock(); try &#123; System.out.println("读取data数据值为：" + data); TimeUnit.SECONDS.sleep(1); System.out.println("读线程睡眠1秒"); &#125; finally &#123; readLock.unlock(); &#125; &#125; public void store() throws InterruptedException &#123; writeLock.lock(); try &#123; data = random.nextInt(100); System.out.println("写入data数据的值为：" + data); TimeUnit.SECONDS.sleep(1); System.out.println("写线程睡眠1秒"); &#125; finally &#123; writeLock.unlock(); &#125; &#125; public static void main(String[] args) throws InterruptedException, BrokenBarrierException &#123; ReentrantReadWriteLockStudy readWriteLockStudy = new ReentrantReadWriteLockStudy(); CyclicBarrier barrier = new CyclicBarrier(6); ExecutorService threadPool = Executors.newFixedThreadPool(10); // 读锁可以共享访问的测试 for (int i = 0; i &lt; 5; i++) &#123; threadPool.submit(() -&gt; &#123; readWriteLockStudy.load(); barrier.await(); return null; &#125;); &#125; barrier.await(); System.out.println("读锁可以共享访问"); // 写锁必须互斥访问的测试 for (int i = 0; i &lt; 5; i++) &#123; threadPool.submit(() -&gt; &#123; readWriteLockStudy.store(); barrier.await(); return null; &#125;); &#125; barrier.await(); System.out.println("写锁必须互斥访问"); threadPool.shutdown(); &#125;&#125; 执行结果1234567891011121314151617181920212223242526"D:\Program Files\Java\jdk1.8.0_51\bin\java" "-javaagent:E:\Program Files\JetBrains\IntelliJ IDEA 2017.3.5\lib\idea_rt.jar=55275:E:\Program Files\JetBrains\IntelliJ IDEA 2017.3.5\bin" -Dfile.encoding=UTF-8 -classpath "D:\Program Files\Java\jdk1.8.0_51\jre\lib\charsets.jar;D:\Program Files\Java\jdk1.8.0_51\jre\lib\deploy.jar;D:\Program Files\Java\jdk1.8.0_51\jre\lib\ext\access-bridge-64.jar;D:\Program Files\Java\jdk1.8.0_51\jre\lib\ext\cldrdata.jar;D:\Program Files\Java\jdk1.8.0_51\jre\lib\ext\dnsns.jar;D:\Program Files\Java\jdk1.8.0_51\jre\lib\ext\jaccess.jar;D:\Program Files\Java\jdk1.8.0_51\jre\lib\ext\jfxrt.jar;D:\Program Files\Java\jdk1.8.0_51\jre\lib\ext\localedata.jar;D:\Program Files\Java\jdk1.8.0_51\jre\lib\ext\nashorn.jar;D:\Program Files\Java\jdk1.8.0_51\jre\lib\ext\sunec.jar;D:\Program Files\Java\jdk1.8.0_51\jre\lib\ext\sunjce_provider.jar;D:\Program Files\Java\jdk1.8.0_51\jre\lib\ext\sunmscapi.jar;D:\Program Files\Java\jdk1.8.0_51\jre\lib\ext\sunpkcs11.jar;D:\Program Files\Java\jdk1.8.0_51\jre\lib\ext\zipfs.jar;D:\Program Files\Java\jdk1.8.0_51\jre\lib\javaws.jar;D:\Program Files\Java\jdk1.8.0_51\jre\lib\jce.jar;D:\Program Files\Java\jdk1.8.0_51\jre\lib\jfr.jar;D:\Program Files\Java\jdk1.8.0_51\jre\lib\jfxswt.jar;D:\Program Files\Java\jdk1.8.0_51\jre\lib\jsse.jar;D:\Program Files\Java\jdk1.8.0_51\jre\lib\management-agent.jar;D:\Program Files\Java\jdk1.8.0_51\jre\lib\plugin.jar;D:\Program Files\Java\jdk1.8.0_51\jre\lib\resources.jar;D:\Program Files\Java\jdk1.8.0_51\jre\lib\rt.jar;D:\IdeaProjects\pattern\target\classes;E:\mylib\repository\org\junit\jupiter\junit-jupiter-api\5.3.0-M1\junit-jupiter-api-5.3.0-M1.jar;E:\mylib\repository\org\apiguardian\apiguardian-api\1.0.0\apiguardian-api-1.0.0.jar;E:\mylib\repository\org\opentest4j\opentest4j\1.1.0\opentest4j-1.1.0.jar;E:\mylib\repository\org\junit\platform\junit-platform-commons\1.3.0-M1\junit-platform-commons-1.3.0-M1.jar;E:\mylib\repository\com\google\guava\guava\25.1-jre\guava-25.1-jre.jar;E:\mylib\repository\com\google\code\findbugs\jsr305\3.0.2\jsr305-3.0.2.jar;E:\mylib\repository\org\checkerframework\checker-qual\2.0.0\checker-qual-2.0.0.jar;E:\mylib\repository\com\google\errorprone\error_prone_annotations\2.1.3\error_prone_annotations-2.1.3.jar;E:\mylib\repository\com\google\j2objc\j2objc-annotations\1.1\j2objc-annotations-1.1.jar;E:\mylib\repository\org\codehaus\mojo\animal-sniffer-annotations\1.14\animal-sniffer-annotations-1.14.jar" cn.com.sunzhiqiang.java.lock.readwritelock.ReentrantReadWriteLockStudy读取data数据值为：1读取data数据值为：1读取data数据值为：1读取data数据值为：1读取data数据值为：1读线程睡眠1秒读线程睡眠1秒读线程睡眠1秒读线程睡眠1秒读线程睡眠1秒读锁可以共享访问=========================写入data数据的值为：56写线程睡眠1秒写入data数据的值为：50写线程睡眠1秒写入data数据的值为：3写线程睡眠1秒写入data数据的值为：33写线程睡眠1秒写入data数据的值为：62写线程睡眠1秒写锁必须互斥访问Process finished with exit code 0 如上： 当一个线程获取读锁后睡眠1秒，此时该线程仍然持有锁。但输出结果可以看出其他线程还可以继续获取读锁，所有读锁是共享的访问方式。 当一个线程获取写锁后睡眠1秒，此时其他线程无法再获取写锁，所以写锁是互斥访问。 读锁会阻塞写锁的获取，写锁会阻塞读锁和写锁的获取下面以代码的形式展示一下读锁与写锁之间的同步控制。 读锁阻塞写锁的获取123456789101112131415161718192021@Testpublic void testReadBlockWrite() throws InterruptedException &#123; ReentrantReadWriteLockStudy readWriteLockStudy = new ReentrantReadWriteLockStudy(); CountDownLatch countDownLatch = new CountDownLatch(2); ExecutorService threadPool = Executors.newFixedThreadPool(2); threadPool.submit(() -&gt; &#123; readWriteLockStudy.load(); countDownLatch.countDown(); return null; &#125;); threadPool.submit(() -&gt; &#123; readWriteLockStudy.store(); countDownLatch.countDown(); return null; &#125;); countDownLatch.await(); System.out.println("读锁会阻塞写锁的获取。");&#125; 执行结果12345678"D:\Program Files\Java\jdk1.8.0_51\bin\java" -ea -Didea.test.cyclic.buffer.size=1048576 "-javaagent:E:\Program Files\JetBrains\IntelliJ IDEA 2017.3.5\lib\idea_rt.jar=55545:E:\Program Files\JetBrains\IntelliJ IDEA 2017.3.5\bin" -Dfile.encoding=UTF-8 -classpath "E:\Program Files\JetBrains\IntelliJ IDEA 2017.3.5\lib\idea_rt.jar;E:\Program Files\JetBrains\IntelliJ IDEA 2017.3.5\plugins\junit\lib\junit-rt.jar;E:\Program Files\JetBrains\IntelliJ IDEA 2017.3.5\plugins\junit\lib\junit5-rt.jar;C:\Users\shuzhiqiang\.m2\repository\org\junit\platform\junit-platform-launcher\1.3.0-M1\junit-platform-launcher-1.3.0-M1.jar;C:\Users\shuzhiqiang\.m2\repository\org\apiguardian\apiguardian-api\1.0.0\apiguardian-api-1.0.0.jar;C:\Users\shuzhiqiang\.m2\repository\org\junit\platform\junit-platform-engine\1.3.0-M1\junit-platform-engine-1.3.0-M1.jar;C:\Users\shuzhiqiang\.m2\repository\org\junit\platform\junit-platform-commons\1.3.0-M1\junit-platform-commons-1.3.0-M1.jar;C:\Users\shuzhiqiang\.m2\repository\org\opentest4j\opentest4j\1.1.0\opentest4j-1.1.0.jar;C:\Users\shuzhiqiang\.m2\repository\org\junit\jupiter\junit-jupiter-engine\5.3.0-M1\junit-jupiter-engine-5.3.0-M1.jar;C:\Users\shuzhiqiang\.m2\repository\org\junit\jupiter\junit-jupiter-api\5.3.0-M1\junit-jupiter-api-5.3.0-M1.jar;D:\Program Files\Java\jdk1.8.0_51\jre\lib\charsets.jar;D:\Program Files\Java\jdk1.8.0_51\jre\lib\deploy.jar;D:\Program Files\Java\jdk1.8.0_51\jre\lib\ext\access-bridge-64.jar;D:\Program Files\Java\jdk1.8.0_51\jre\lib\ext\cldrdata.jar;D:\Program Files\Java\jdk1.8.0_51\jre\lib\ext\dnsns.jar;D:\Program Files\Java\jdk1.8.0_51\jre\lib\ext\jaccess.jar;D:\Program Files\Java\jdk1.8.0_51\jre\lib\ext\jfxrt.jar;D:\Program Files\Java\jdk1.8.0_51\jre\lib\ext\localedata.jar;D:\Program Files\Java\jdk1.8.0_51\jre\lib\ext\nashorn.jar;D:\Program Files\Java\jdk1.8.0_51\jre\lib\ext\sunec.jar;D:\Program Files\Java\jdk1.8.0_51\jre\lib\ext\sunjce_provider.jar;D:\Program Files\Java\jdk1.8.0_51\jre\lib\ext\sunmscapi.jar;D:\Program Files\Java\jdk1.8.0_51\jre\lib\ext\sunpkcs11.jar;D:\Program Files\Java\jdk1.8.0_51\jre\lib\ext\zipfs.jar;D:\Program Files\Java\jdk1.8.0_51\jre\lib\javaws.jar;D:\Program Files\Java\jdk1.8.0_51\jre\lib\jce.jar;D:\Program Files\Java\jdk1.8.0_51\jre\lib\jfr.jar;D:\Program Files\Java\jdk1.8.0_51\jre\lib\jfxswt.jar;D:\Program Files\Java\jdk1.8.0_51\jre\lib\jsse.jar;D:\Program Files\Java\jdk1.8.0_51\jre\lib\management-agent.jar;D:\Program Files\Java\jdk1.8.0_51\jre\lib\plugin.jar;D:\Program Files\Java\jdk1.8.0_51\jre\lib\resources.jar;D:\Program Files\Java\jdk1.8.0_51\jre\lib\rt.jar;D:\IdeaProjects\pattern\target\classes;E:\mylib\repository\org\junit\jupiter\junit-jupiter-api\5.3.0-M1\junit-jupiter-api-5.3.0-M1.jar;E:\mylib\repository\org\apiguardian\apiguardian-api\1.0.0\apiguardian-api-1.0.0.jar;E:\mylib\repository\org\opentest4j\opentest4j\1.1.0\opentest4j-1.1.0.jar;E:\mylib\repository\org\junit\platform\junit-platform-commons\1.3.0-M1\junit-platform-commons-1.3.0-M1.jar;E:\mylib\repository\com\google\guava\guava\25.1-jre\guava-25.1-jre.jar;E:\mylib\repository\com\google\code\findbugs\jsr305\3.0.2\jsr305-3.0.2.jar;E:\mylib\repository\org\checkerframework\checker-qual\2.0.0\checker-qual-2.0.0.jar;E:\mylib\repository\com\google\errorprone\error_prone_annotations\2.1.3\error_prone_annotations-2.1.3.jar;E:\mylib\repository\com\google\j2objc\j2objc-annotations\1.1\j2objc-annotations-1.1.jar;E:\mylib\repository\org\codehaus\mojo\animal-sniffer-annotations\1.14\animal-sniffer-annotations-1.14.jar" com.intellij.rt.execution.junit.JUnitStarter -ideVersion5 -junit5 cn.com.sunzhiqiang.java.lock.readwritelock.ReentrantReadWriteLockStudy,testReadBlockWrite读取data数据值为：1读线程睡眠1秒写入data数据的值为：59写线程睡眠1秒读锁会阻塞写锁的获取。Process finished with exit code 0 写锁阻塞读锁的获取123456789101112131415161718192021@Testpublic void testWriteBlockRead() throws InterruptedException &#123; ReentrantReadWriteLockStudy readWriteLockStudy = new ReentrantReadWriteLockStudy(); CountDownLatch countDownLatch = new CountDownLatch(2); ExecutorService threadPool = Executors.newFixedThreadPool(2); threadPool.submit(() -&gt; &#123; readWriteLockStudy.store(); countDownLatch.countDown(); return null; &#125;); threadPool.submit(() -&gt; &#123; readWriteLockStudy.load(); countDownLatch.countDown(); return null; &#125;); countDownLatch.await(); System.out.println("写锁会阻塞读锁的获取。");&#125; 执行结果12345678"D:\Program Files\Java\jdk1.8.0_51\bin\java" -ea -Didea.test.cyclic.buffer.size=1048576 "-javaagent:E:\Program Files\JetBrains\IntelliJ IDEA 2017.3.5\lib\idea_rt.jar=55556:E:\Program Files\JetBrains\IntelliJ IDEA 2017.3.5\bin" -Dfile.encoding=UTF-8 -classpath "E:\Program Files\JetBrains\IntelliJ IDEA 2017.3.5\lib\idea_rt.jar;E:\Program Files\JetBrains\IntelliJ IDEA 2017.3.5\plugins\junit\lib\junit-rt.jar;E:\Program Files\JetBrains\IntelliJ IDEA 2017.3.5\plugins\junit\lib\junit5-rt.jar;C:\Users\shuzhiqiang\.m2\repository\org\junit\platform\junit-platform-launcher\1.3.0-M1\junit-platform-launcher-1.3.0-M1.jar;C:\Users\shuzhiqiang\.m2\repository\org\apiguardian\apiguardian-api\1.0.0\apiguardian-api-1.0.0.jar;C:\Users\shuzhiqiang\.m2\repository\org\junit\platform\junit-platform-engine\1.3.0-M1\junit-platform-engine-1.3.0-M1.jar;C:\Users\shuzhiqiang\.m2\repository\org\junit\platform\junit-platform-commons\1.3.0-M1\junit-platform-commons-1.3.0-M1.jar;C:\Users\shuzhiqiang\.m2\repository\org\opentest4j\opentest4j\1.1.0\opentest4j-1.1.0.jar;C:\Users\shuzhiqiang\.m2\repository\org\junit\jupiter\junit-jupiter-engine\5.3.0-M1\junit-jupiter-engine-5.3.0-M1.jar;C:\Users\shuzhiqiang\.m2\repository\org\junit\jupiter\junit-jupiter-api\5.3.0-M1\junit-jupiter-api-5.3.0-M1.jar;D:\Program Files\Java\jdk1.8.0_51\jre\lib\charsets.jar;D:\Program Files\Java\jdk1.8.0_51\jre\lib\deploy.jar;D:\Program Files\Java\jdk1.8.0_51\jre\lib\ext\access-bridge-64.jar;D:\Program Files\Java\jdk1.8.0_51\jre\lib\ext\cldrdata.jar;D:\Program Files\Java\jdk1.8.0_51\jre\lib\ext\dnsns.jar;D:\Program Files\Java\jdk1.8.0_51\jre\lib\ext\jaccess.jar;D:\Program Files\Java\jdk1.8.0_51\jre\lib\ext\jfxrt.jar;D:\Program Files\Java\jdk1.8.0_51\jre\lib\ext\localedata.jar;D:\Program Files\Java\jdk1.8.0_51\jre\lib\ext\nashorn.jar;D:\Program Files\Java\jdk1.8.0_51\jre\lib\ext\sunec.jar;D:\Program Files\Java\jdk1.8.0_51\jre\lib\ext\sunjce_provider.jar;D:\Program Files\Java\jdk1.8.0_51\jre\lib\ext\sunmscapi.jar;D:\Program Files\Java\jdk1.8.0_51\jre\lib\ext\sunpkcs11.jar;D:\Program Files\Java\jdk1.8.0_51\jre\lib\ext\zipfs.jar;D:\Program Files\Java\jdk1.8.0_51\jre\lib\javaws.jar;D:\Program Files\Java\jdk1.8.0_51\jre\lib\jce.jar;D:\Program Files\Java\jdk1.8.0_51\jre\lib\jfr.jar;D:\Program Files\Java\jdk1.8.0_51\jre\lib\jfxswt.jar;D:\Program Files\Java\jdk1.8.0_51\jre\lib\jsse.jar;D:\Program Files\Java\jdk1.8.0_51\jre\lib\management-agent.jar;D:\Program Files\Java\jdk1.8.0_51\jre\lib\plugin.jar;D:\Program Files\Java\jdk1.8.0_51\jre\lib\resources.jar;D:\Program Files\Java\jdk1.8.0_51\jre\lib\rt.jar;D:\IdeaProjects\pattern\target\classes;E:\mylib\repository\org\junit\jupiter\junit-jupiter-api\5.3.0-M1\junit-jupiter-api-5.3.0-M1.jar;E:\mylib\repository\org\apiguardian\apiguardian-api\1.0.0\apiguardian-api-1.0.0.jar;E:\mylib\repository\org\opentest4j\opentest4j\1.1.0\opentest4j-1.1.0.jar;E:\mylib\repository\org\junit\platform\junit-platform-commons\1.3.0-M1\junit-platform-commons-1.3.0-M1.jar;E:\mylib\repository\com\google\guava\guava\25.1-jre\guava-25.1-jre.jar;E:\mylib\repository\com\google\code\findbugs\jsr305\3.0.2\jsr305-3.0.2.jar;E:\mylib\repository\org\checkerframework\checker-qual\2.0.0\checker-qual-2.0.0.jar;E:\mylib\repository\com\google\errorprone\error_prone_annotations\2.1.3\error_prone_annotations-2.1.3.jar;E:\mylib\repository\com\google\j2objc\j2objc-annotations\1.1\j2objc-annotations-1.1.jar;E:\mylib\repository\org\codehaus\mojo\animal-sniffer-annotations\1.14\animal-sniffer-annotations-1.14.jar" com.intellij.rt.execution.junit.JUnitStarter -ideVersion5 -junit5 cn.com.sunzhiqiang.java.lock.readwritelock.ReentrantReadWriteLockStudy,testWriteBlockRead写入data数据的值为：87写线程睡眠1秒读取data数据值为：87读线程睡眠1秒写锁会阻塞读锁的获取。Process finished with exit code 0 锁降级如果当前线程持有写锁，那么它也可以获取到读锁，如果这时释放写锁，该线程所持有的锁变成了只有读锁。完成了从写锁-&gt;读锁的变化，这就是锁降级。下面还是以代码的形式来演示一下锁降级。123456789101112131415161718192021222324@Testpublic void testDowngradeLock() &#123; ReentrantReadWriteLockStudy readWriteLockStudy = new ReentrantReadWriteLockStudy(); // 获取写锁 readWriteLockStudy.writeLock.lock(); try &#123; // 修改数据 readWriteLockStudy.data = 10; // 同一线程获取读锁 readWriteLockStudy.readLock.lock(); &#125; finally &#123; // 释放写锁 readWriteLockStudy.writeLock.unlock(); &#125; try &#123; // 此时该线程只持有读锁 System.out.println("读取到data数据：" + readWriteLockStudy.data); &#125; finally &#123; readWriteLockStudy.readLock.unlock(); &#125;&#125; 执行结果123读取到data数据：10Process finished with exit code 0]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内部类]]></title>
    <url>%2F2018%2F11%2F04%2F%E5%86%85%E9%83%A8%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[概述内部类是java常用语法，但使用方法却常常被用错，下面会以代码的方式，演示内部类的使用。 内部类的分类内部类可以分为： 静态内部类 成员内部类 局部内部类 匿名内部类 这是根据类的位置来定义内部类的。也有认为静态内部类不属于内部类而属于嵌套类的说法。不管怎样，我们不必纠结于定义。 内部类的声明123456789101112131415161718192021222324252627282930/** * 功能描述: 内部类学习 * * @author sunzhiqiang * @create 2018-11-04 */public class InnerClassStudy &#123; // 成员内部类 class InnerClass &#123; &#125; // 静态内部类 static class StaticInnerClass &#123; &#125; public void method()&#123; // 局部内部类 class LocalInnerClass&#123; &#125; new Thread(new Runnable() &#123; //匿名内部类 @Override public void run() &#123; &#125; &#125;); &#125; 内部类对象的创建123456789101112131415161718192021@Testpublic void testCreateInnerClassInstance() &#123; // 成员内部类持有外部类的引用，必须先实例化外部类才能实例化内部类 InnerClass innerClass = new InnerClassStudy().new InnerClass(); // 静态内部类不持有外部类的引用，所以可以直接new创建 StaticInnerClass staticInnerClass = new InnerClassStudy.StaticInnerClass(); // 局部内部类只能在方法中创建,基本上不用 class LocalInnerClass&#123; &#125; new LocalInnerClass(); // 匿名内部类常用在接口回调中,下面创建了一个实现了Runnable接口的类的对象 new Thread(new Runnable() &#123; @Override public void run() &#123; &#125; &#125;);&#125; 内部类访问外部类成员12345678910111213141516171819202122232425262728293031323334353637public class InnerClassStudy &#123; private static int a; private int b; // 成员内部类 class InnerClass &#123; void method() &#123; System.out.println(a);//成员内部类可以访问外部类的静态成员 System.out.println(b); //成员内部类可以访问外部类的实例成员 &#125; &#125; // 静态内部类 static class StaticInnerClass &#123; void method() &#123; System.out.println(a);//静态内部类只能访问外部类的静态成员 &#125; &#125; public void method() &#123; // 局部内部类 class LocalInnerClass &#123; void method() &#123; System.out.println(a); System.out.println(b); &#125; &#125; new Thread(new Runnable() &#123; //匿名内部类 @Override public void run() &#123; System.out.println(a); System.out.println(b); &#125; &#125;); &#125; 如上面的代码所示： 成员内部类可以访问外部类的所有成员，因为成员内部类含有外部类的引用； 局部内部类和匿名内部类也可以访问外部类的所有成员，因为方法参数里默认会带有this对象，所以也相当于含有外部类的引用； 静态内部类只能访问外部类的静态成员，因为静态内部类和外部类没有关系，也正因为如此，在《effective java》一书中，将静态内部类归于嵌套类，其余3种内部类统称为内部类。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程池(2)-线程池的使用]]></title>
    <url>%2F2018%2F11%2F04%2F%E7%BA%BF%E7%A8%8B%E6%B1%A0-2-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[前言在之前的文章中介绍过线程池的创建，下面会介绍一下如何使用线程池。 使用线程池的案例下面是一个使用线程池的小例子，通过这个例子来验证一下线程池的原理。12345678910111213141516171819202122232425262728293031323334353637383940414243@Testpublic void useThreadPool() throws Exception &#123; // 创建线程池 ThreadPoolExecutor threadPool = new ThreadPoolExecutor( 4, 6, 2, TimeUnit.SECONDS, new LinkedBlockingDeque&lt;&gt;(10) ); try &#123; // 测试线程数小于核心池大小 testThreadPool(threadPool, 3, "第一轮测试结束，测试线程数为3，小于核心池大小。"); // 测试线程数等于核心池大小 testThreadPool(threadPool, 4, "第二轮测试结束，测试线程数为4，等于核心池大小。"); // 测试线程数大于核心池大小，但小于核心池加任务队列大小 testThreadPool(threadPool, 9, "第三轮测试结束，测试线程数为9，大于核心池大小，没超过任务队列限制。"); // 测试线程数大于核心池和任务队列的大小和，但小于最大池大小和任务队列大小和 testThreadPool(threadPool, 16, "第四轮测试结束，测试线程数为16，大于核心池加任务队列，小于最大池加任务队列。"); // 测试线程数大于线程池最大容量，默认饱和策略 testThreadPool(threadPool, 20, "第五轮测试结束，测试线程数为20，大于线程池最大容量，默认饱和策略抛出异常。" ); &#125; finally &#123; threadPool.shutdown(); &#125;&#125; 12345678910111213141516private void testThreadPool(ThreadPoolExecutor threadPool, int threadCount, String message) throws Exception &#123; CountDownLatch countDownLatch = new CountDownLatch(threadCount); for (int i = 0; i &lt; threadCount; i++) &#123; threadPool.submit(() -&gt; &#123; System.out.println(Thread.currentThread().getName()); TimeUnit.SECONDS.sleep(1); countDownLatch.countDown(); return null; &#125;); &#125; countDownLatch.await(); System.out.println(message);&#125; 执行结果123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101"D:\Program Files\Java\jdk1.8.0_51\bin\java" -ea -Didea.test.cyclic.buffer.size=1048576 "-javaagent:E:\Program Files\JetBrains\IntelliJ IDEA 2017.3.5\lib\idea_rt.jar=64061:E:\Program Files\JetBrains\IntelliJ IDEA 2017.3.5\bin" -Dfile.encoding=UTF-8 -classpath "E:\Program Files\JetBrains\IntelliJ IDEA 2017.3.5\lib\idea_rt.jar;E:\Program Files\JetBrains\IntelliJ IDEA 2017.3.5\plugins\junit\lib\junit-rt.jar;E:\Program Files\JetBrains\IntelliJ IDEA 2017.3.5\plugins\junit\lib\junit5-rt.jar;C:\Users\shuzhiqiang\.m2\repository\org\junit\platform\junit-platform-launcher\1.3.0-M1\junit-platform-launcher-1.3.0-M1.jar;C:\Users\shuzhiqiang\.m2\repository\org\apiguardian\apiguardian-api\1.0.0\apiguardian-api-1.0.0.jar;C:\Users\shuzhiqiang\.m2\repository\org\junit\platform\junit-platform-engine\1.3.0-M1\junit-platform-engine-1.3.0-M1.jar;C:\Users\shuzhiqiang\.m2\repository\org\junit\platform\junit-platform-commons\1.3.0-M1\junit-platform-commons-1.3.0-M1.jar;C:\Users\shuzhiqiang\.m2\repository\org\opentest4j\opentest4j\1.1.0\opentest4j-1.1.0.jar;C:\Users\shuzhiqiang\.m2\repository\org\junit\jupiter\junit-jupiter-engine\5.3.0-M1\junit-jupiter-engine-5.3.0-M1.jar;C:\Users\shuzhiqiang\.m2\repository\org\junit\jupiter\junit-jupiter-api\5.3.0-M1\junit-jupiter-api-5.3.0-M1.jar;D:\Program Files\Java\jdk1.8.0_51\jre\lib\charsets.jar;D:\Program Files\Java\jdk1.8.0_51\jre\lib\deploy.jar;D:\Program Files\Java\jdk1.8.0_51\jre\lib\ext\access-bridge-64.jar;D:\Program Files\Java\jdk1.8.0_51\jre\lib\ext\cldrdata.jar;D:\Program Files\Java\jdk1.8.0_51\jre\lib\ext\dnsns.jar;D:\Program Files\Java\jdk1.8.0_51\jre\lib\ext\jaccess.jar;D:\Program Files\Java\jdk1.8.0_51\jre\lib\ext\jfxrt.jar;D:\Program Files\Java\jdk1.8.0_51\jre\lib\ext\localedata.jar;D:\Program Files\Java\jdk1.8.0_51\jre\lib\ext\nashorn.jar;D:\Program Files\Java\jdk1.8.0_51\jre\lib\ext\sunec.jar;D:\Program Files\Java\jdk1.8.0_51\jre\lib\ext\sunjce_provider.jar;D:\Program Files\Java\jdk1.8.0_51\jre\lib\ext\sunmscapi.jar;D:\Program Files\Java\jdk1.8.0_51\jre\lib\ext\sunpkcs11.jar;D:\Program Files\Java\jdk1.8.0_51\jre\lib\ext\zipfs.jar;D:\Program Files\Java\jdk1.8.0_51\jre\lib\javaws.jar;D:\Program Files\Java\jdk1.8.0_51\jre\lib\jce.jar;D:\Program Files\Java\jdk1.8.0_51\jre\lib\jfr.jar;D:\Program Files\Java\jdk1.8.0_51\jre\lib\jfxswt.jar;D:\Program Files\Java\jdk1.8.0_51\jre\lib\jsse.jar;D:\Program Files\Java\jdk1.8.0_51\jre\lib\management-agent.jar;D:\Program Files\Java\jdk1.8.0_51\jre\lib\plugin.jar;D:\Program Files\Java\jdk1.8.0_51\jre\lib\resources.jar;D:\Program Files\Java\jdk1.8.0_51\jre\lib\rt.jar;D:\IdeaProjects\pattern\target\classes;E:\mylib\repository\org\junit\jupiter\junit-jupiter-api\5.3.0-M1\junit-jupiter-api-5.3.0-M1.jar;E:\mylib\repository\org\apiguardian\apiguardian-api\1.0.0\apiguardian-api-1.0.0.jar;E:\mylib\repository\org\opentest4j\opentest4j\1.1.0\opentest4j-1.1.0.jar;E:\mylib\repository\org\junit\platform\junit-platform-commons\1.3.0-M1\junit-platform-commons-1.3.0-M1.jar;E:\mylib\repository\com\google\guava\guava\25.1-jre\guava-25.1-jre.jar;E:\mylib\repository\com\google\code\findbugs\jsr305\3.0.2\jsr305-3.0.2.jar;E:\mylib\repository\org\checkerframework\checker-qual\2.0.0\checker-qual-2.0.0.jar;E:\mylib\repository\com\google\errorprone\error_prone_annotations\2.1.3\error_prone_annotations-2.1.3.jar;E:\mylib\repository\com\google\j2objc\j2objc-annotations\1.1\j2objc-annotations-1.1.jar;E:\mylib\repository\org\codehaus\mojo\animal-sniffer-annotations\1.14\animal-sniffer-annotations-1.14.jar" com.intellij.rt.execution.junit.JUnitStarter -ideVersion5 -junit5 cn.com.sunzhiqiang.java.threadpool.ThreadPoolStudy,useThreadPoolpool-1-thread-1pool-1-thread-2pool-1-thread-3第一轮测试结束，测试线程数为3，小于核心池大小。pool-1-thread-4pool-1-thread-2pool-1-thread-3pool-1-thread-1第二轮测试结束，测试线程数为4，等于核心池大小。pool-1-thread-4pool-1-thread-3pool-1-thread-1pool-1-thread-2pool-1-thread-4pool-1-thread-1pool-1-thread-3pool-1-thread-2pool-1-thread-4第三轮测试结束，测试线程数为9，大于核心池大小，没超过任务队列限制。pool-1-thread-4pool-1-thread-1pool-1-thread-2pool-1-thread-3pool-1-thread-5pool-1-thread-6pool-1-thread-2pool-1-thread-4pool-1-thread-1pool-1-thread-5pool-1-thread-3pool-1-thread-6pool-1-thread-2pool-1-thread-4pool-1-thread-1pool-1-thread-5第四轮测试结束，测试线程数为16，大于核心池加任务队列，小于最大池加任务队列。pool-1-thread-3pool-1-thread-4pool-1-thread-2pool-1-thread-6pool-1-thread-1pool-1-thread-5java.util.concurrent.RejectedExecutionException: Task java.util.concurrent.FutureTask@548e7350 rejected from java.util.concurrent.ThreadPoolExecutor@1a968a59[Running, pool size = 6, active threads = 6, queued tasks = 10, completed tasks = 32] at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2047) at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:823) at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1369) at java.util.concurrent.AbstractExecutorService.submit(AbstractExecutorService.java:134) at cn.com.sunzhiqiang.java.threadpool.ThreadPoolStudy.testThreadPool(ThreadPoolStudy.java:110) at cn.com.sunzhiqiang.java.threadpool.ThreadPoolStudy.useThreadPool(ThreadPoolStudy.java:95) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:497) at org.junit.platform.commons.util.ReflectionUtils.invokeMethod(ReflectionUtils.java:515) at org.junit.jupiter.engine.execution.ExecutableInvoker.invoke(ExecutableInvoker.java:115) at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.lambda$invokeTestMethod$6(TestMethodTestDescriptor.java:170) at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor$$Lambda$181/2094411587.execute(Unknown Source) at org.junit.jupiter.engine.execution.ThrowableCollector.execute(ThrowableCollector.java:40) at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.invokeTestMethod(TestMethodTestDescriptor.java:166) at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:113) at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:58) at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:134) at org.junit.platform.engine.support.hierarchical.NodeTestTask$$Lambda$133/1641808846.execute(Unknown Source) at org.junit.platform.engine.support.hierarchical.SingleTestExecutor.executeSafely(SingleTestExecutor.java:66) at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:128) at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:109) at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService$$Lambda$136/653687670.accept(Unknown Source) at java.util.ArrayList.forEach(ArrayList.java:1249) at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:38) at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:138) at org.junit.platform.engine.support.hierarchical.NodeTestTask$$Lambda$133/1641808846.execute(Unknown Source) at org.junit.platform.engine.support.hierarchical.SingleTestExecutor.executeSafely(SingleTestExecutor.java:66) at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:128) at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:109) at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService$$Lambda$136/653687670.accept(Unknown Source) at java.util.ArrayList.forEach(ArrayList.java:1249) at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:38) at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:138) at org.junit.platform.engine.support.hierarchical.NodeTestTask$$Lambda$133/1641808846.execute(Unknown Source) at org.junit.platform.engine.support.hierarchical.SingleTestExecutor.executeSafely(SingleTestExecutor.java:66) at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:128) at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:109) at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.submit(SameThreadHierarchicalTestExecutorService.java:32) at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:49) at org.junit.platform.engine.support.hierarchical.HierarchicalTestEngine.execute(HierarchicalTestEngine.java:47) at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:184) at org.junit.platform.launcher.core.DefaultLauncher.lambda$execute$5(DefaultLauncher.java:152) at org.junit.platform.launcher.core.DefaultLauncher$$Lambda$107/1792845110.accept(Unknown Source) at org.junit.platform.launcher.core.DefaultLauncher.withInterceptedStreams(DefaultLauncher.java:166) at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:145) at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:92) at com.intellij.junit5.JUnit5IdeaTestRunner.startRunnerWithArgs(JUnit5IdeaTestRunner.java:65) at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:47) at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242) at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70)Process finished with exit code -1 结果分析通过以上代码以及执行结果，可知，线程池的执行流程： 如果核心池没满，使用核心池执行任务 核心池已满，任务队列没满，任务入队 核心池已满，任务队列也满了，使用最大池执行任务 如果最大池已满，新到达的任务会执行饱和策略，默认的饱和策略是抛异常。]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程池(1)-线程池的创建]]></title>
    <url>%2F2018%2F11%2F01%2F%E7%BA%BF%E7%A8%8B%E6%B1%A0-1-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%88%9B%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[前言对于创建和销毁代价比较大的对象，如果创建的比较频繁，一般会用池来缓存对象。但也不是所有的对象都适合缓存，对于创建和销毁代价并不大的对象，还是在使用的时候创建效率高。比较适合池化的对象有数据库连接对象，线程对象等。线程池就是缓存线程的容器。 线程池的创建 使用Executors 123456789101112@Testpublic void createThreadPoolByFactory() &#123; // 创建大小固定的线程池 ExecutorService threadPool = Executors.newFixedThreadPool(4); // 创建大小没限制的线程池 ExecutorService threadPool2 = Executors.newCachedThreadPool(); // 创建只有一个线程的线程池 ExecutorService threadPool3 = Executors.newSingleThreadExecutor();&#125; 使用构造器创建 123456789101112131415161718192021222324252627282930313233@Testpublic void createThreadPoolByConstructor() &#123; // 不指定创建线程的工厂和饱和策略 ThreadPoolExecutor threadPool = new ThreadPoolExecutor( 4, 6, 2, TimeUnit.SECONDS, new LinkedBlockingDeque&lt;&gt;(10) ); // 不指定饱和策略 ThreadPoolExecutor threadPool2 = new ThreadPoolExecutor( 4, 6, 2, TimeUnit.SECONDS, new LinkedBlockingDeque&lt;&gt;(10), new MyThreadFactory() ); // 包含创建线程池的所有参数 ThreadPoolExecutor threadPool3 = new ThreadPoolExecutor( 4,//核心池大小 6,//最大池的大小 2,//线程空闲时，存活时间 TimeUnit.SECONDS,//线程空闲时，存活时间单位 new LinkedBlockingDeque&lt;&gt;(10),//任务队列 new MyThreadFactory(),//自定义的线程工厂 new ThreadPoolExecutor.AbortPolicy()//线程池饱和时的策略 );&#125; 线程池原理如上图1和图2所展示的，线程池的执行流程分4步： 如果核心线程池没有满，任务会提交给核心线程池来执行。 如果核心线程池满了，任务会提交到任务队列。 如果任务队列也满了，任务会提交到最大线程池去执行。 如果最大线程池也满了（线程池达到饱和状态），线程池会对后续的任务执行特定策略。 饱和策略 AbortPolicy： 直接拒绝所提交的任务，并抛出RejectedExecutionException异常 CallerRunsPolicy：只用调用者所在的线程来执行任务； DiscardPolicy：不处理直接丢弃掉任务； DiscardOldestPolicy：丢弃掉阻塞队列中存放时间最久的任务，执行当前任务 结束语以上是线程池的创建和基本原理，会在之后的文章里建设线程池的使用以及线程池的源码解析。]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生产者消费者模型]]></title>
    <url>%2F2018%2F10%2F28%2F%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[概述生成者-消费者模型是一个应用很广的模型，广泛应用在RPC框架以及消息队列等。它通过增加一个队列消除了生成者与消费者之间的耦合。下面会用代码演示一下常用的实现生产者-消费者方式。 代码演示 Object的wait/notifyAll机制 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119import java.util.LinkedList;import java.util.List;import java.util.Random;import java.util.concurrent.TimeUnit;/** * 功能描述: 通过Object的wait/notifyAll机制实现生产者-消费者模式 * * @author sunzhiqiang * @create 2018-10-28 */public class ProducerConsumerPatternByWaitAndNotify &#123; /** * 自定义一个阻塞队列 * * @param &lt;T&gt; */ static class MyBlockQueue&lt;T&gt; &#123; private Object lock = new Object(); private List&lt;T&gt; list = new LinkedList&lt;&gt;(); private final int size; public MyBlockQueue(int size) &#123; this.size = size; &#125; public void put(T t) throws InterruptedException &#123; synchronized (lock) &#123; while (list.size() == size) &#123; System.out.println("阻塞队列已满，生产者等待队列不满。"); lock.wait(); &#125; list.add(t); System.out.println("生产者放入：" + t); lock.notifyAll(); &#125; &#125; public &lt;T&gt; T get() throws InterruptedException &#123; synchronized (lock) &#123; while (list.size() == 0) &#123; System.out.println("阻塞队列为空，消费者等待队列不空。"); lock.wait(); &#125; T t = (T) list.remove(0); System.out.println("消费者消费了：" + t); lock.notifyAll(); return t; &#125; &#125; &#125; /** * 生成者任务 */ static class Producer implements Runnable &#123; private MyBlockQueue queue; Producer(MyBlockQueue queue) &#123; this.queue = queue; &#125; @Override public void run() &#123; Random random = new Random(); while (true) &#123; try &#123; TimeUnit.SECONDS.sleep(1); queue.put(random.nextInt(10)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; /** * 消费者任务 */ static class Consumer implements Runnable &#123; private MyBlockQueue queue; Consumer(MyBlockQueue queue) &#123; this.queue = queue; &#125; @Override public void run() &#123; while (true) &#123; try &#123; TimeUnit.SECONDS.sleep(2); queue.get(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; /** * 客户端类 * * @param args */ public static void main(String[] args) &#123; MyBlockQueue&lt;Integer&gt; queue = new MyBlockQueue&lt;&gt;(10); new Thread(new Producer(queue)).start(); new Thread(new Consumer(queue)).start(); new Thread(new Consumer(queue)).start(); new Thread(new Producer(queue)).start(); &#125;&#125; Condition的await/signalAll 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132import java.util.LinkedList;import java.util.List;import java.util.Random;import java.util.concurrent.TimeUnit;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;/** * 功能描述: 通过condition实现生产者-消费者模式 * * @author sunzhiqiang * @create 2018-10-28 */public class ProducerConsumerPatternByCondition &#123; /** * 自定义一个阻塞队列 * * @param &lt;T&gt; */ static class MyBlockQueue&lt;T&gt; &#123; private Lock lock = new ReentrantLock(); private Condition notEmpty = lock.newCondition(); private Condition notFull = lock.newCondition(); private List&lt;T&gt; list = new LinkedList&lt;&gt;(); private final int size; public MyBlockQueue(int size) &#123; this.size = size; &#125; public void put(T t) throws InterruptedException &#123; lock.lock(); try &#123; while (list.size() == size) &#123; System.out.println("阻塞队列已满，生产者等待队列不满。"); notFull.await(); &#125; list.add(t); System.out.println("生产者放入：" + t); notEmpty.signalAll(); &#125; finally &#123; lock.unlock(); &#125; &#125; public &lt;T&gt; T get() throws InterruptedException &#123; lock.lock(); try &#123; while (list.size() == 0) &#123; System.out.println("阻塞队列为空，消费者等待队列不空。"); notEmpty.await(); &#125; T t = (T) list.remove(0); System.out.println("消费者消费了：" + t); notFull.signalAll(); return t; &#125; finally &#123; lock.unlock(); &#125; &#125; &#125; /** * 生成者任务 */ static class Producer implements Runnable &#123; private MyBlockQueue queue; Producer(MyBlockQueue queue) &#123; this.queue = queue; &#125; @Override public void run() &#123; Random random = new Random(); while (true) &#123; try &#123; TimeUnit.SECONDS.sleep(1); queue.put(random.nextInt(10)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; /** * 消费者任务 */ static class Consumer implements Runnable &#123; private MyBlockQueue queue; Consumer(MyBlockQueue queue) &#123; this.queue = queue; &#125; @Override public void run() &#123; while (true) &#123; try &#123; TimeUnit.SECONDS.sleep(2); queue.get(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; /** * 客户端类 * * @param args */ public static void main(String[] args) &#123; MyBlockQueue&lt;Integer&gt; queue = new MyBlockQueue&lt;&gt;(10); new Thread(new Producer(queue)).start(); new Thread(new Consumer(queue)).start(); new Thread(new Consumer(queue)).start(); new Thread(new Producer(queue)).start(); &#125;&#125; 阻塞队列 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115import java.util.Random;import java.util.concurrent.BlockingQueue;import java.util.concurrent.LinkedBlockingQueue;import java.util.concurrent.TimeUnit;/** * 功能描述: 通过BlockingQueue来实现生产者-消费者模型 * * @author sunzhiqiang * @create 2018-10-28 */public class ProducerConsumerPatternByBlockingQueue &#123; /** * 自定义一个阻塞队列 * * @param &lt;T&gt; */ static class MyBlockQueue&lt;T&gt; &#123; private BlockingQueue&lt;T&gt; queue; private final int size; public MyBlockQueue(int size) &#123; this.size = size; queue = new LinkedBlockingQueue&lt;&gt;(size); &#125; public void put(T t) throws InterruptedException &#123; if (queue.size() == size) &#123; System.out.println("阻塞队列已满，生产者等待队列不满。"); &#125; queue.put(t); System.out.println("生产者放入：" + t); &#125; public &lt;T&gt; T get() throws InterruptedException &#123; if (queue.size() == 0) &#123; System.out.println("阻塞队列为空，消费者等待队列不空。"); &#125; T t = (T) queue.take(); System.out.println("消费者消费了：" + t); return t; &#125; &#125; /** * 生成者任务 */ static class Producer implements Runnable &#123; private MyBlockQueue queue; Producer(MyBlockQueue queue) &#123; this.queue = queue; &#125; @Override public void run() &#123; Random random = new Random(); while (true) &#123; try &#123; TimeUnit.SECONDS.sleep(1); queue.put(random.nextInt(10)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; /** * 消费者任务 */ static class Consumer implements Runnable &#123; private MyBlockQueue queue; Consumer(MyBlockQueue queue) &#123; this.queue = queue; &#125; @Override public void run() &#123; while (true) &#123; try &#123; TimeUnit.SECONDS.sleep(1); queue.get(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; /** * 客户端类 * * @param args */ public static void main(String[] args) &#123; MyBlockQueue&lt;Integer&gt; queue = new MyBlockQueue&lt;&gt;(10); new Thread(new Producer(queue)).start(); new Thread(new Consumer(queue)).start(); new Thread(new Consumer(queue)).start(); new Thread(new Producer(queue)).start(); &#125;&#125; 信号量 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135import java.util.LinkedList;import java.util.List;import java.util.Random;import java.util.concurrent.Semaphore;import java.util.concurrent.TimeUnit;/** * 功能描述: 通过信号量实现生产者-消费者模式 * * @author sunzhiqiang * @create 2018-10-28 */public class ProducerConsumerPatternBySemaphore &#123; /** * 自定义一个阻塞队列 * * @param &lt;T&gt; */ static class MyBlockQueue&lt;T&gt; &#123; private Semaphore notFull; private Semaphore notEmpty; private Semaphore mutex; private List&lt;T&gt; queue; private final int size; public MyBlockQueue(int size) &#123; this.size = size; notFull = new Semaphore(size); notEmpty = new Semaphore(0); mutex = new Semaphore(1); queue = new LinkedList&lt;&gt;(); &#125; public void put(T t) throws InterruptedException &#123; if (queue.size() == size) &#123; System.out.println("阻塞队列已满，生产者等待队列不满。"); &#125; notFull.acquire(); mutex.acquire(); try &#123; queue.add(t); System.out.println("生产者放入：" + t); notEmpty.release(); &#125; finally &#123; mutex.release(); &#125; &#125; public &lt;T&gt; T get() throws InterruptedException &#123; if (queue.size() == 0) &#123; System.out.println("阻塞队列为空，消费者等待队列不空。"); &#125; notEmpty.acquire(); mutex.acquire(); try &#123; T t = (T) queue.remove(0); System.out.println("消费者消费了：" + t); notFull.release(); return t; &#125; finally &#123; mutex.release(); &#125; &#125; &#125; /** * 生成者任务 */ static class Producer implements Runnable &#123; private MyBlockQueue queue; Producer(MyBlockQueue queue) &#123; this.queue = queue; &#125; @Override public void run() &#123; Random random = new Random(); while (true) &#123; try &#123; TimeUnit.SECONDS.sleep(2); queue.put(random.nextInt(10)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; /** * 消费者任务 */ static class Consumer implements Runnable &#123; private MyBlockQueue queue; Consumer(MyBlockQueue queue) &#123; this.queue = queue; &#125; @Override public void run() &#123; while (true) &#123; try &#123; TimeUnit.SECONDS.sleep(1); queue.get(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; /** * 客户端类 * * @param args */ public static void main(String[] args) &#123; MyBlockQueue&lt;Integer&gt; queue = new MyBlockQueue&lt;&gt;(10); new Thread(new Producer(queue)).start(); new Thread(new Consumer(queue)).start(); new Thread(new Consumer(queue)).start(); new Thread(new Producer(queue)).start(); &#125;&#125;]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Condition]]></title>
    <url>%2F2018%2F10%2F27%2FCondition%2F</url>
    <content type="text"><![CDATA[前言谈到Condition,需要先了解Object类的notify/notifyAll方法，以及wait方法。notify/notifyAll以及wait方法共同构建了等待某一个对象的等待队列。下面用代码的方式来演示一下notify/wait的使用。 notify/wait12345678910111213141516171819202122232425262728/** * 功能描述: 学习notify/wait * * @author sunzhiqiang * @create 2018-10-27 */public class NotifyAndWaitStudy &#123; public static void main(String[] args) throws InterruptedException &#123; Object lock = new Object(); Thread thread1 = new Thread(() -&gt; &#123; synchronized (lock) &#123; System.out.println(Thread.currentThread().getName() + "获得锁"); lock.notifyAll(); &#125; &#125;); synchronized (lock) &#123; System.out.println(Thread.currentThread().getName() + "获得锁"); thread1.start(); Thread.sleep(1000); //确保thread1已经开始执行，等待获取锁 lock.wait(); System.out.println(Thread.currentThread().getName() + "被唤醒"); &#125; &#125;&#125; 执行结果 主线程先获得锁 主线程开启thread1,并睡眠1秒，确保thread1已经开始运行，等待获取锁。 主线程调用wait方法释放锁。 thread1线程获取锁后执行notify方法，唤醒等待在lock锁的条件队列中的主线程。 主线程被唤醒。 Lock的ConditionReentrantLock是基于AQS实现的，AQS维护了2个队列来实现同步： 一个是同步队列（等待获取锁） 一个是等待队列（等待某一个Condition被满足） Lock.newCondition()会创建一个condition条件，等待该条件被满足的线程会构成一个等待队列。下面用代码演示一下Condition的使用。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131import java.util.LinkedList;import java.util.List;import java.util.Random;import java.util.concurrent.TimeUnit;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;/** * 功能描述: Condition学习 * * @author sunzhiqiang * @create 2018-10-28 */public class ConditionStudy &#123; /** * 自定义一个阻塞队列 * * @param &lt;T&gt; */ static class MyBlockQueue&lt;T&gt; &#123; private Lock lock = new ReentrantLock(); private Condition notEmpty = lock.newCondition(); private Condition notFull = lock.newCondition(); private List&lt;T&gt; list = new LinkedList&lt;&gt;(); private final int size; public MyBlockQueue(int size) &#123; this.size = size; &#125; public void put(T t) throws InterruptedException &#123; lock.lock(); try &#123; while (list.size() == size) &#123; System.out.println("阻塞队列已满，生产者等待队列不满。"); notFull.await(); &#125; list.add(t); System.out.println("生产者放入：" + t); notEmpty.signalAll(); &#125; finally &#123; lock.unlock(); &#125; &#125; public &lt;T&gt; T get() throws InterruptedException &#123; lock.lock(); try &#123; while (list.size() == 0) &#123; System.out.println("阻塞队列为空，消费者等待队列不空。"); notEmpty.await(); &#125; T t = (T) list.remove(0); System.out.println("消费者消费了：" + t); notFull.signalAll(); return t; &#125; finally &#123; lock.unlock(); &#125; &#125; &#125; /** * 生成者任务 */ static class Producer implements Runnable &#123; private MyBlockQueue queue; Producer(MyBlockQueue queue) &#123; this.queue = queue; &#125; @Override public void run() &#123; Random random = new Random(); while (true) &#123; try &#123; TimeUnit.SECONDS.sleep(1); queue.put(random.nextInt(10)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; /** * 消费者任务 */ static class Consumer implements Runnable &#123; private MyBlockQueue queue; Consumer(MyBlockQueue queue) &#123; this.queue = queue; &#125; @Override public void run() &#123; while (true) &#123; try &#123; TimeUnit.SECONDS.sleep(2); queue.get(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; /** * 客户端类 * @param args */ public static void main(String[] args) &#123; MyBlockQueue&lt;Integer&gt; queue = new MyBlockQueue&lt;&gt;(10); new Thread(new Producer(queue)).start(); new Thread(new Consumer(queue)).start(); new Thread(new Consumer(queue)).start(); new Thread(new Producer(queue)).start(); &#125;&#125; 执行结果：上面我们通过Condition的await/signalAll方法，简易实现了阻塞队列的基本功能，并以此构建了生产者-消费者模式。与Object的wait/notifyAll相比，Condition能够更加细粒度的控制线程的等待和唤醒。]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ReentrantLock]]></title>
    <url>%2F2018%2F10%2F25%2FReentrantLock%2F</url>
    <content type="text"><![CDATA[概述jdk1.5以前要实现多线程同步只能使用synchronized关键字， synchronized关键字有以下3个局限性: 不响应中断，不支持非阻塞模式，不支持超时等待锁 不支持公平锁 只能有一个等待队列（notify(notifyAll)/wait机制） jdk1.5之后，JUC包下新增了许多类来弥补synchronized关键字功能上的不足，下面是JUC包下lock子包的图： locks子包介绍如上图，locks子包下提供了丰富的类来实现同步功能, AbstractOwnableSynchronizer,AbstractQueuedLongSynchronizer,AbstractQueuedSynchronizer3个类是实现同步器的底层框架。Lock和Condition接口定义了锁和等待队列的方法规范。LockSupport类用来实现线程的挂起和恢复。ReentrantLock类是可重入的互斥锁。ReadWriteLock接口和ReentrantReadWriteLock类实现了读写锁。(读锁允许多线程并发访问，写锁只能互斥访问)。StampedLock类是1.8新加入的一个类，它扩展了读写锁，增加了一种乐观读的模式，在乐观读模式不会阻塞写线程。 ReentrantLock使用下面我们会介绍ReentrantLock的用法。 创建一个非公平锁12ReentrantLock lock = new ReentrantLock();ReentrantLock lock1 = new ReentrantLock(false); 调用无参构造器或者调用一个参数的构造器（参数false）会创建一个非公平锁。 创建一个公平锁1ReentrantLock lock2 = new ReentrantLock(true); 调用一个参数的构造器（参数true）会场景一个公平锁。公平锁和非公平锁是什么呢？公平锁就是严格的按照先进先出，先等待锁的线程一定会先获得锁。非公平锁不保证先等待锁的线程一定会先获得锁。 不响应中断的阻塞锁 123456789101112131415161718@Testpublic void testLock() throws InterruptedException &#123; for (int i = 0; i &lt; 100; i++) &#123; threadPool.submit(() -&gt; &#123; lock.lock(); try &#123; count++; countDownLatch.countDown(); &#125; finally &#123; lock.unlock(); &#125; &#125;); &#125; countDownLatch.await(); System.out.println(String.format("计数器i的值:%d", count));&#125; lock与synchronized不同的是，lock需要手动释放，为了确保lock.unlock()能够执行，需要把lock放在finally代码块里，lock.lock()一定要放在try代码块的外面，如果获取锁时发生异常，锁获取失败，一定不能执行unlock()方法。 非阻塞锁 123456789101112131415161718192021@Testpublic void testTryLock() throws InterruptedException &#123; for (int i = 0; i &lt; 100; i++) &#123; threadPool.submit(() -&gt; &#123; boolean isLock = false; while (!isLock) &#123; isLock = lock.tryLock(); &#125; try &#123; count++; countDownLatch.countDown(); &#125; finally &#123; lock.unlock(); &#125; &#125;); &#125; countDownLatch.await(); System.out.println(String.format("计数器i的值:%d", count));&#125; 响应中断的锁 12345678910111213141516171819202122232425262728293031323334353637383940 @Test public void testLockInterruptibly() throws InterruptedException &#123; Thread thread1 = new Thread(() -&gt; &#123; try &#123; lock.lockInterruptibly(); &#125; catch (InterruptedException e) &#123; System.out.println("Thread1发生中断"); Thread.currentThread().interrupt(); return; &#125; try &#123; System.out.println("thread1获取到锁"); &#125; finally &#123; lock.unlock(); &#125; &#125;); Thread thread2 = new Thread(() -&gt; &#123; lock.lock(); try &#123; System.out.println("thread2获取到锁"); &#125; finally &#123; lock.unlock(); &#125; &#125;); lock.lock(); //主线程先获取锁 try &#123; thread1.start(); thread2.start(); Thread.sleep(1000); //等待thread1和thread2阻塞在获取锁的步骤 thread1.interrupt(); thread2.interrupt(); &#125; finally &#123; Thread.sleep(2000); //主线程等待2秒再释放锁 lock.unlock(); &#125; &#125;&#125; 执行结果 主线程先获取锁 然后开始thread1和thread2 主线程睡眠1秒（不释放锁，并等1秒，确保thread1和thread2在获取锁的地方阻塞） 主线程中断thread1,thread2 thread1会响应中断，打印thread1发生中断 2秒后主线程释放锁，thread2获取锁，打印thread2获取到锁 限时等待锁123456789101112131415161718192021222324@Testpublic void testTryLockTime() throws Exception &#123; threadPool.submit(() -&gt; &#123; cyclicBarrier.await(); boolean isLock = false; while (!isLock) &#123; long startTime = System.currentTimeMillis(); isLock = lock.tryLock(1, TimeUnit.SECONDS); long waitTime = (System.currentTimeMillis() - startTime) / 1000L; System.out.println(isLock ? "获取到锁" : String.format("被中断或者超时，获取锁失败,等待时间为:%d秒", waitTime)); &#125; lock.unlock(); return null; &#125;); lock.lock(); try &#123; cyclicBarrier.await(); // CyclicBarrier(2)，当有2个线程调用await方法，屏障被突破 Thread.sleep(2000); &#125; finally &#123; lock.unlock(); &#125;&#125; 执行结果 getHoldCountReentrantLock是可重入的，即获取锁的线程可以再次获取该锁。getHoldCount方法可以得出持有锁的线程获取了多少次锁。 1234567891011121314@Testpublic void testGetHoldCount()&#123; lock.lock(); System.out.println("当前线程持有的锁的次数：" + lock.getHoldCount()); //当前线程持有的锁的次数：1 lock.lock(); System.out.println("当前线程持有的锁的次数：" + lock.getHoldCount()); //当前线程持有的锁的次数：2 lock.lock(); System.out.println("当前线程持有的锁的次数：" + lock.getHoldCount()); //当前线程持有的锁的次数：3 lock.unlock(); lock.unlock(); lock.unlock();&#125; isHeldByCurrentThread判断当前线程是否持有锁 1234567891011121314151617@Testpublic void testIsHeldByCurrentThread() throws Exception &#123; threadPool.submit(() -&gt; &#123; cyclicBarrier.await(); System.out.println(Thread.currentThread().getName() + "线程是否持有锁：" + lock.isHeldByCurrentThread()); return null; &#125;); lock.lock(); try &#123; cyclicBarrier.await(); System.out.println(Thread.currentThread().getName() + "线程是否持有锁：" + lock.isHeldByCurrentThread()); &#125; finally &#123; lock.unlock(); &#125;&#125; 执行结果 其它API 12345public boolean isLocked();//lock是否处于锁定状态public final boolean isFair();//是否是公平锁public final boolean hasQueuedThreads();//是否有线程在等待获取锁public final boolean hasQueuedThread(Thread thread);//参数传入的Thread对象是否在等待获取该锁public final int getQueueLength();//等待获取该锁的线程数 与Condition相关的api 123public Condition newCondition();public boolean hasWaiters(Condition condition);public int getWaitQueueLength(Condition condition); 上面3个接口是与Condition相关的,Condition的内容会在其它文章里介绍。]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nohup命令以及&]]></title>
    <url>%2F2018%2F10%2F24%2Fnohup%E5%91%BD%E4%BB%A4%E4%BB%A5%E5%8F%8A%2F</url>
    <content type="text"><![CDATA[概述在使用linux过程中,我们经常会希望命令在后台运行,实现这个需要我们可以使用ctrl+z组合键或者&amp;符号. 后台运行命令ctrl+z1.正常运行命令2.按ctrl+z组合键,让命令到后台运行3.使用jobs -l查看后台运行的命令4.使用bg %1让后台命令变为运行态,%表示后台命令,1表示后台命令的ID 使用&amp;1.也可以直接使用&amp;符号把命令放到后台运行2.使用jobs -l查看命令的运行状态 nohup上面的方式实现了让命令后台运行,但有个问题是,一旦退出当前的shell,命令就会终止,解决办法是使用nohup这个命令.]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[责任链模式]]></title>
    <url>%2F2018%2F10%2F24%2F%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[模式的定义使多个对象都有机会处理请求,从而避免请求的发送者和接收者之间的耦合关系.将这些对象连成一条链,并沿着这条链传递该请求,直到有一个对象处理它为止. 代码演示BUG修复接口,所有模块的BUG修复都要继承该接口.一个BUG可能会设计到多个模块的修复. 抽象的组件1234567891011121314151617181920/** * @author sunzhiqiang * @date 2018/10/10 * @desc 责任链模式（BUG修改接口） */public abstract class BUGRepair &#123; private BUGRepair next; public abstract void repairBUG(); public BUGRepair setNext(BUGRepair next) &#123; this.next = next; return next; &#125; public BUGRepair getNext() &#123; return next; &#125;&#125; 具体的组件12345678910111213141516/** * @author sunzhiqiang * @date 2018/10/10 * @desc 责任链模式（模块A的BUG修复） */public class ModuleA_BUGRepair extends BUGRepair &#123; @Override public void repairBUG() &#123; System.out.println("模块A的BUG修复了"); if (getNext() != null) &#123; getNext().repairBUG(); &#125; &#125;&#125; 12345678910111213141516/** * @author sunzhiqiang * @date 2018/10/10 * @desc 责任链模式（模块B的BUG修复） */public class ModuleB_BUGRepair extends BUGRepair &#123; @Override public void repairBUG() &#123; System.out.println("模块B的BUG修复了"); if (getNext() != null) &#123; getNext().repairBUG(); &#125; &#125;&#125; 12345678910111213141516/** * @author sunzhiqiang * @date 2018/10/10 * @desc 责任链模式（模块C的BUG修复） */public class ModuleC_BUGRepair extends BUGRepair &#123; @Override public void repairBUG() &#123; System.out.println("模块C的BUG修复了"); if (getNext() != null) &#123; getNext().repairBUG(); &#125; &#125;&#125; 客户端类1234567891011121314/** * @author sunzhiqiang * @date 2018/10/10 * @desc 客户端类 */public class Client &#123; public static void main(String[] args) &#123; BUGRepair bugRepair = new ModuleA_BUGRepair(); bugRepair.setNext(new ModuleB_BUGRepair()).setNext(new ModuleC_BUGRepair()); bugRepair.repairBUG(); &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo admin部署]]></title>
    <url>%2F2018%2F10%2F24%2Fhexo-admin%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[概述hexo是目前使用较广的静态博客系统,它提供了丰富的主题,以及简单的使用方式,对markdown的支持,使它成为搭建个人博客的首选之一. 搭建思路hexo的缺点是不能像wordpress那样有后台,部署到服务器上,随时随地的编辑和发布.但是hexo-admin插件解决了这个问题.1.在阿里云上安装hexo以及hexo-admin(需要node.js的环境).2.编辑发布脚本.3.安装git,连接远程github,使用github page来提供web服务.]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CyclicBarrier类]]></title>
    <url>%2F2018%2F09%2F16%2FCyclicBarrier%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[概述CyclicBarrier是java.util.concurrent包下的工具类.用来提供控制多线程同时开始或者同时结束的方法. 源码分析成员变量这个类共有6个成员变量1234567891011121314151617/** The lock for guarding barrier entry */private final ReentrantLock lock = new ReentrantLock();/** Condition to wait on until tripped */private final Condition trip = lock.newCondition();/** The number of parties */private final int parties;/* The command to run when tripped */private final Runnable barrierCommand;/** The current generation */private Generation generation = new Generation();/** * Number of parties still waiting. Counts down from parties to 0 * on each generation. It is reset to parties on each new * generation or when broken. */private int count; lock用来控制多线程互斥访问.trip用来控制线程等待与唤醒.parties参与同时执行或者同时结束的线程数.barrierCommand当所有等待的线程被唤醒后执行的任务.generation用来表示barrier是否被突破(等待的线程数等于parties时),是一个boolean值的封装.1234567891011121314/** * Each use of the barrier is represented as a generation instance. * The generation changes whenever the barrier is tripped, or * is reset. There can be many generations associated with threads * using the barrier - due to the non-deterministic way the lock * may be allocated to waiting threads - but only one of these * can be active at a time (the one to which &#123;@code count&#125; applies) * and all the rest are either broken or tripped. * There need not be an active generation if there has been a break * but no subsequent reset. */private static class Generation &#123; boolean broken = false;&#125; count表示barrier被突破,仍然需要等待的线程数.初始时等于parties,没有一个线程等待,就减1,当count=0是,trip条件队列唤醒所有等待中线程. 方法构造方法2个参数的构造方法.123456789101112131415161718/** * Creates a new &#123;@code CyclicBarrier&#125; that will trip when the * given number of parties (threads) are waiting upon it, and which * will execute the given barrier action when the barrier is tripped, * performed by the last thread entering the barrier. * * @param parties the number of threads that must invoke &#123;@link #await&#125; * before the barrier is tripped * @param barrierAction the command to execute when the barrier is * tripped, or &#123;@code null&#125; if there is no action * @throws IllegalArgumentException if &#123;@code parties&#125; is less than 1 */public CyclicBarrier(int parties, Runnable barrierAction) &#123; if (parties &lt;= 0) throw new IllegalArgumentException(); this.parties = parties; this.count = parties; this.barrierCommand = barrierAction;&#125; 第一个参数是参入等待的总线程数,第二个参数是当Condition条件队列唤醒所有等待的线程是执行的任务.一个参数的构造方法.123456789101112/** * Creates a new &#123;@code CyclicBarrier&#125; that will trip when the * given number of parties (threads) are waiting upon it, and * does not perform a predefined action when the barrier is tripped. * * @param parties the number of threads that must invoke &#123;@link #await&#125; * before the barrier is tripped * @throws IllegalArgumentException if &#123;@code parties&#125; is less than 1 */public CyclicBarrier(int parties) &#123; this(parties, null);&#125; 公有apipublic int getParties()12345678/** * Returns the number of parties required to trip this barrier. * * @return the number of parties required to trip this barrier */public int getParties() &#123; return parties;&#125; 获取突破barrier需要等待的总线程数.public int await() throws InterruptedException, BrokenBarrierException12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * Waits until all &#123;@linkplain #getParties parties&#125; have invoked * &#123;@code await&#125; on this barrier. * * &lt;p&gt;If the current thread is not the last to arrive then it is * disabled for thread scheduling purposes and lies dormant until * one of the following things happens: * &lt;ul&gt; * &lt;li&gt;The last thread arrives; or * &lt;li&gt;Some other thread &#123;@linkplain Thread#interrupt interrupts&#125; * the current thread; or * &lt;li&gt;Some other thread &#123;@linkplain Thread#interrupt interrupts&#125; * one of the other waiting threads; or * &lt;li&gt;Some other thread times out while waiting for barrier; or * &lt;li&gt;Some other thread invokes &#123;@link #reset&#125; on this barrier. * &lt;/ul&gt; * * &lt;p&gt;If the current thread: * &lt;ul&gt; * &lt;li&gt;has its interrupted status set on entry to this method; or * &lt;li&gt;is &#123;@linkplain Thread#interrupt interrupted&#125; while waiting * &lt;/ul&gt; * then &#123;@link InterruptedException&#125; is thrown and the current thread's * interrupted status is cleared. * * &lt;p&gt;If the barrier is &#123;@link #reset&#125; while any thread is waiting, * or if the barrier &#123;@linkplain #isBroken is broken&#125; when * &#123;@code await&#125; is invoked, or while any thread is waiting, then * &#123;@link BrokenBarrierException&#125; is thrown. * * &lt;p&gt;If any thread is &#123;@linkplain Thread#interrupt interrupted&#125; while waiting, * then all other waiting threads will throw * &#123;@link BrokenBarrierException&#125; and the barrier is placed in the broken * state. * * &lt;p&gt;If the current thread is the last thread to arrive, and a * non-null barrier action was supplied in the constructor, then the * current thread runs the action before allowing the other threads to * continue. * If an exception occurs during the barrier action then that exception * will be propagated in the current thread and the barrier is placed in * the broken state. * * @return the arrival index of the current thread, where index * &#123;@code getParties() - 1&#125; indicates the first * to arrive and zero indicates the last to arrive * @throws InterruptedException if the current thread was interrupted * while waiting * @throws BrokenBarrierException if &lt;em&gt;another&lt;/em&gt; thread was * interrupted or timed out while the current thread was * waiting, or the barrier was reset, or the barrier was * broken when &#123;@code await&#125; was called, or the barrier * action (if present) failed due to an exception */public int await() throws InterruptedException, BrokenBarrierException &#123; try &#123; return dowait(false, 0L); &#125; catch (TimeoutException toe) &#123; throw new Error(toe); // cannot happen &#125;&#125; 调用这个方法,使线程进入等待状态.内部调用了private int dowait(boolean timed, long nanos)方法.下面是其源码.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/** * Main barrier code, covering the various policies. */private int dowait(boolean timed, long nanos) throws InterruptedException, BrokenBarrierException, TimeoutException &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; final Generation g = generation; if (g.broken) throw new BrokenBarrierException(); if (Thread.interrupted()) &#123; breakBarrier(); throw new InterruptedException(); &#125; int index = --count; if (index == 0) &#123; // tripped boolean ranAction = false; try &#123; final Runnable command = barrierCommand; if (command != null) command.run(); ranAction = true; nextGeneration(); return 0; &#125; finally &#123; if (!ranAction) breakBarrier(); &#125; &#125; // loop until tripped, broken, interrupted, or timed out for (;;) &#123; try &#123; if (!timed) trip.await(); else if (nanos &gt; 0L) nanos = trip.awaitNanos(nanos); &#125; catch (InterruptedException ie) &#123; if (g == generation &amp;&amp; ! g.broken) &#123; breakBarrier(); throw ie; &#125; else &#123; // We're about to finish waiting even if we had not // been interrupted, so this interrupt is deemed to // "belong" to subsequent execution. Thread.currentThread().interrupt(); &#125; &#125; if (g.broken) throw new BrokenBarrierException(); if (g != generation) return index; if (timed &amp;&amp; nanos &lt;= 0L) &#123; breakBarrier(); throw new TimeoutException(); &#125; &#125; &#125; finally &#123; lock.unlock(); &#125;&#125; 第12-13行,判断如果当前的barrier已经被突破,直接抛出异常.第15-18行,判断如果线程被中断,调用breakBarrier()方法,并抛出中断异常.下面是breakBarrier()的源码.123456789/** * Sets current barrier generation as broken and wakes up everyone. * Called only while holding lock. */private void breakBarrier() &#123; generation.broken = true; count = parties; trip.signalAll();&#125; 可以看到,这个方法会标识barrier为被突破的状态,重置count为初始值,并唤醒所有线程.第20-34行,执行count–,并判断count是否等于0,如果等于0执行barrierCommand成员变量表示的任务.并调用nextGeneration()开启一个新的barrier生命周期.如果执行过程中,发送异常,调用breakBarrier()方法,结束barrier.下面是nextGeneration()的源码.1234567891011/** * Updates state on barrier trip and wakes up everyone. * Called only while holding lock. */private void nextGeneration() &#123; // signal completion of last generation trip.signalAll(); // set up next generation count = parties; generation = new Generation();&#125; 可以看到执行的操作是唤醒所有等待该Condition条件队列的线程.并重置barrier的状态.第36到65行,执行当count&gt;0时的逻辑,具体是,先判断传入的timed变量(即是是否使用限制时间的等待),如果等于false,线程进入等待状态.当需要按时间等待,但等待的时间参入值&lt;=0时,barrier结束,抛出超时异常.当线程被唤醒后,通过generation来判断是因为异常被唤醒,还是因为正常结束被唤醒,如果因为异常被唤醒,抛出BrokenBarrierException异常.如果正常结束,返回当前线程是第几个进入等待状态的线程.public int await(long timeout, TimeUnit unit) throws InterruptedException, BrokenBarrierException, TimeoutException123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/** * Waits until all &#123;@linkplain #getParties parties&#125; have invoked * &#123;@code await&#125; on this barrier, or the specified waiting time elapses. * * &lt;p&gt;If the current thread is not the last to arrive then it is * disabled for thread scheduling purposes and lies dormant until * one of the following things happens: * &lt;ul&gt; * &lt;li&gt;The last thread arrives; or * &lt;li&gt;The specified timeout elapses; or * &lt;li&gt;Some other thread &#123;@linkplain Thread#interrupt interrupts&#125; * the current thread; or * &lt;li&gt;Some other thread &#123;@linkplain Thread#interrupt interrupts&#125; * one of the other waiting threads; or * &lt;li&gt;Some other thread times out while waiting for barrier; or * &lt;li&gt;Some other thread invokes &#123;@link #reset&#125; on this barrier. * &lt;/ul&gt; * * &lt;p&gt;If the current thread: * &lt;ul&gt; * &lt;li&gt;has its interrupted status set on entry to this method; or * &lt;li&gt;is &#123;@linkplain Thread#interrupt interrupted&#125; while waiting * &lt;/ul&gt; * then &#123;@link InterruptedException&#125; is thrown and the current thread's * interrupted status is cleared. * * &lt;p&gt;If the specified waiting time elapses then &#123;@link TimeoutException&#125; * is thrown. If the time is less than or equal to zero, the * method will not wait at all. * * &lt;p&gt;If the barrier is &#123;@link #reset&#125; while any thread is waiting, * or if the barrier &#123;@linkplain #isBroken is broken&#125; when * &#123;@code await&#125; is invoked, or while any thread is waiting, then * &#123;@link BrokenBarrierException&#125; is thrown. * * &lt;p&gt;If any thread is &#123;@linkplain Thread#interrupt interrupted&#125; while * waiting, then all other waiting threads will throw &#123;@link * BrokenBarrierException&#125; and the barrier is placed in the broken * state. * * &lt;p&gt;If the current thread is the last thread to arrive, and a * non-null barrier action was supplied in the constructor, then the * current thread runs the action before allowing the other threads to * continue. * If an exception occurs during the barrier action then that exception * will be propagated in the current thread and the barrier is placed in * the broken state. * * @param timeout the time to wait for the barrier * @param unit the time unit of the timeout parameter * @return the arrival index of the current thread, where index * &#123;@code getParties() - 1&#125; indicates the first * to arrive and zero indicates the last to arrive * @throws InterruptedException if the current thread was interrupted * while waiting * @throws TimeoutException if the specified timeout elapses. * In this case the barrier will be broken. * @throws BrokenBarrierException if &lt;em&gt;another&lt;/em&gt; thread was * interrupted or timed out while the current thread was * waiting, or the barrier was reset, or the barrier was broken * when &#123;@code await&#125; was called, or the barrier action (if * present) failed due to an exception */public int await(long timeout, TimeUnit unit) throws InterruptedException, BrokenBarrierException, TimeoutException &#123; return dowait(true, unit.toNanos(timeout));&#125; 限时版本的等待方法,和await所调用的内部方法一样.public boolean isBroken()1234567891011121314151617/** * Queries if this barrier is in a broken state. * * @return &#123;@code true&#125; if one or more parties broke out of this * barrier due to interruption or timeout since * construction or the last reset, or a barrier action * failed due to an exception; &#123;@code false&#125; otherwise. */public boolean isBroken() &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; return generation.broken; &#125; finally &#123; lock.unlock(); &#125;&#125; 判断当前barrier是否因为异常情况被突破.public void reset()12345678910111213141516171819/** * Resets the barrier to its initial state. If any parties are * currently waiting at the barrier, they will return with a * &#123;@link BrokenBarrierException&#125;. Note that resets &lt;em&gt;after&lt;/em&gt; * a breakage has occurred for other reasons can be complicated to * carry out; threads need to re-synchronize in some other way, * and choose one to perform the reset. It may be preferable to * instead create a new barrier for subsequent use. */public void reset() &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; breakBarrier(); // break the current generation nextGeneration(); // start a new generation &#125; finally &#123; lock.unlock(); &#125;&#125; 重置barrier状态.public int getNumberWaiting()123456789101112131415/** * Returns the number of parties currently waiting at the barrier. * This method is primarily useful for debugging and assertions. * * @return the number of parties currently blocked in &#123;@link #await&#125; */public int getNumberWaiting() &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; return parties - count; &#125; finally &#123; lock.unlock(); &#125;&#125; 获取等待被唤醒的线程数. 小结CyclicBarrier类是多线程常用工具类,能够实现多线程同时开始或者同时结束的特殊效果,并且api使用简单,是一个我们应该去查看源码进行学习的类.]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unsafe类]]></title>
    <url>%2F2018%2F09%2F05%2FUnSafe%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[概述Unsafe类是一个不建议使用的类,就像名字一样,是一个不安全的类.这个类有着直接操作内存,不执行初始化就创建对象,以及很多的CAS方法等等.功能非常强大.所以,虽然不建议使用,但还是很有必要了解这个类,而且JAVA9把这个类修改为可以直接创建对象使用,说明以后它的用途可能会越来越广.有必要系统的学习一下这个类. 功能学习创建Unsafe类的对象Unsafe类的对象在应用程序里不能直接创建,因为该类只能由启动类加载器来加载.但可以使用反射来创建该类的对象.(JAVA9好像可以直接创建该类的对象了)1234567891011121314/** * Unsafe类创建对象 * * @return * @throws NoSuchFieldException * @throws IllegalAccessException */private static Unsafe getUnsafe() throws NoSuchFieldException, IllegalAccessException &#123; // Unsafe对象的创建 Field field = Unsafe.class.getDeclaredField("theUnsafe"); field.setAccessible(true); Unsafe unsafe = (Unsafe) field.get(null); return unsafe;&#125; 操作实例变量的值该类所有的实例变量12345678910111213141516/** * 功能描述: UnSafe类学习 * * @author sunzhiqiang * @create 2018-09-05 */public class UnsafeStudy &#123; private int b = 2; private static int c = 3; private long e = 1; class InnerClass &#123; private int a = 2; private int d = 4; &#125; 操作实例变量的代码12345678910111213/** * 测试获取对象的值和设置对象的值 * * @param unsafe * @throws NoSuchFieldException */private static void testObjectField(Unsafe unsafe) throws NoSuchFieldException &#123; InnerClass innerClass = new UnsafeStudy().new InnerClass(); int a = unsafe.getInt(innerClass, unsafe.objectFieldOffset(InnerClass.class.getDeclaredField("a"))); System.out.println("通过getInt获取的对象的实例变量值:" + a); unsafe.putInt(innerClass, unsafe.objectFieldOffset(InnerClass.class.getDeclaredField("a")), 3); System.out.println("通过putInt重新设置值后:" + innerClass.a);&#125; 操作类变量123456789101112/** * 获取和设置静态字段的值 * * @param unsafe * @throws NoSuchFieldException */private static void testStaticField(Unsafe unsafe) throws NoSuchFieldException &#123; Object obj = unsafe.staticFieldBase(UnsafeStudy.class.getDeclaredField("c")); long staticFieldOffset = unsafe.staticFieldOffset(UnsafeStudy.class.getDeclaredField("c")); long staticFieldValue = unsafe.getInt(obj, staticFieldOffset); System.out.println(staticFieldValue);&#125; 操作数组1234567891011121314/** * 测试操作数组 * * @param unsafe */private static void testArray(Unsafe unsafe) &#123; int[] intArray = new int[]&#123;1, 2, 3, 4, 5&#125;; int base = unsafe.arrayBaseOffset(int[].class); int offset = unsafe.arrayIndexScale(int[].class); System.out.println("数组中第一个元素的值:" + unsafe.getInt(intArray, base)); System.out.println("数组中第二个元素的值:" + unsafe.getInt(intArray, base + offset)); unsafe.putInt(intArray, base + offset, 8); System.out.println("重新设置数组中第二个元素的值:" + unsafe.getInt(intArray, base + offset));&#125; 操作内存12345678910111213141516171819202122232425262728293031/** * Unsafe类分配内存,设置值,重新分配内存,复制内存释放内存 * * @param unsafe * @throws InterruptedException */private static void testMemory(Unsafe unsafe) throws InterruptedException &#123; long memoryAddress = unsafe.allocateMemory(1); System.out.println("分配的内存地址为:" + memoryAddress); unsafe.setMemory(memoryAddress, 1, (byte) 1); System.out.println("设置内存里的数据为:" + unsafe.getByte(memoryAddress)); long secondAddress = unsafe.reallocateMemory(memoryAddress, 1); System.out.println("重新分配的内存地址为:" + secondAddress); unsafe.setMemory(secondAddress, 1, (byte) 2); System.out.println("设置内存里的数据为:" + unsafe.getByte(secondAddress)); System.out.println("测试内存复制"); long oneAddress = unsafe.allocateMemory(1); long twoAddress = unsafe.allocateMemory(1); unsafe.setMemory(oneAddress, 1, (byte) 1); unsafe.setMemory(twoAddress, 1, (byte) 2); System.out.println("被复制的值:" + unsafe.getByte(oneAddress)); System.out.println("复制前:" + unsafe.getByte(twoAddress)); unsafe.copyMemory(oneAddress, twoAddress, 1); System.out.println("复制后:" + unsafe.getByte(twoAddress)); unsafe.freeMemory(memoryAddress); unsafe.freeMemory(secondAddress); unsafe.freeMemory(oneAddress); unsafe.freeMemory(twoAddress);&#125; 操作内存绝对地址12345678910111213/** * 测试操作address相关 * * @param unsafe */private static void testAddress(Unsafe unsafe) &#123; long memoryAddress = unsafe.allocateMemory(1); System.out.println("分配的内存地址为:" + memoryAddress); unsafe.putAddress(memoryAddress, 2); long value = unsafe.getAddress(memoryAddress); System.out.println("getAddress方法获取的值为:" + value); System.out.println("getByte方法获取的值:" + unsafe.getByte(memoryAddress));&#125; 创建其他类的对象1234567891011121314/** * 使用Unsafe类创建对象 * * @param unsafe * @throws InstantiationException */private static void testCreateInstance(Unsafe unsafe) throws InstantiationException &#123; UnsafeStudy unsafeStudy = UnsafeStudy.class.cast(unsafe.allocateInstance(UnsafeStudy.class)); UnsafeStudy unsafeStudy1 = new UnsafeStudy(); System.out.println("通过new关键字创建的对象的实例变量:" + unsafeStudy1.b); System.out.println("通过new关键字创建的对象的静态变量:" + unsafeStudy1.c); System.out.println("通过allocateInstance创建的对象的实例变量:" + unsafeStudy.b); System.out.println("通过allocateInstance创建的对象的静态变量:" + unsafeStudy.c);&#125; 实现锁机制123456789101112131415161718/** * Unsafe实现锁相关操作 * * @param unsafe * @throws InterruptedException */private static void testMonitor(Unsafe unsafe) throws InterruptedException &#123; ExecutorService executorService = Executors.newFixedThreadPool(4); for (int i = 0; i &lt; 4; i++) &#123; executorService.submit(() -&gt; testLock(unsafe)); &#125; unsafe.tryMonitorEnter(UnsafeStudy.class); System.out.println("主线程获取到锁"); UnsafeStudy.c++; Thread.sleep(1000); System.out.println("等待结束"); unsafe.monitorExit(UnsafeStudy.class);&#125; 123456private static void testLock(Unsafe unsafe) &#123; unsafe.monitorEnter(UnsafeStudy.class); System.out.println("当前线程为:" + Thread.currentThread().getName()); System.out.println("测试monitor,i = " + UnsafeStudy.c++); unsafe.monitorExit(UnsafeStudy.class);&#125; checked异常转unchecked异常12345678/** * 异常相关 * * @param unsafe */private static void testException(Unsafe unsafe) &#123; unsafe.throwException(new Exception("异常测试"));&#125; CAS(Compare And Swap)123456789101112/** * CAS相关 * * @param unsafe * @throws NoSuchFieldException */private static void testCAS(Unsafe unsafe) throws NoSuchFieldException &#123; UnsafeStudy unsafeStudy = new UnsafeStudy(); long offset = unsafe.objectFieldOffset(UnsafeStudy.class.getDeclaredField("b")); System.out.println(unsafe.compareAndSwapInt(unsafeStudy, offset, 2, 3)); System.out.println(unsafe.compareAndSwapInt(unsafeStudy, offset, 2, 3));&#125; 支持volatile原语的get和set12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * 测试支持volatile语意的设置和获取 * * @param unsafe * @throws NoSuchFieldException */private static void testVolatilePutAndGet(Unsafe unsafe) throws NoSuchFieldException, BrokenBarrierException, InterruptedException &#123; UnsafeStudy unsafeStudy = new UnsafeStudy(); long offset = unsafe.objectFieldOffset(UnsafeStudy.class.getDeclaredField("e")); ExecutorService executorService = Executors.newFixedThreadPool(2); CyclicBarrier cyclicBarrier = new CyclicBarrier(3); System.out.println("第一轮执行getLong测试开始"); executorService.submit(() -&gt; &#123; unsafe.putLong(unsafeStudy, offset, 3); System.out.println(Thread.currentThread().getName() + "设置值为:" + unsafeStudy.e); cyclicBarrier.await(); return null; &#125;); executorService.submit(() -&gt; &#123; long value = unsafe.getLong(unsafeStudy, offset); System.out.println(Thread.currentThread().getName() + "获取值为:" + value); cyclicBarrier.await(); return null; &#125;); cyclicBarrier.await(); System.out.println("第一轮测试结束"); cyclicBarrier.reset(); System.out.println("第二轮执行getLongVolatile测试开始"); executorService.submit(() -&gt; &#123; unsafe.putLongVolatile(unsafeStudy, offset, 4); System.out.println(Thread.currentThread().getName() + "设置值为:" + unsafeStudy.e); cyclicBarrier.await(); return null; &#125;); executorService.submit(() -&gt; &#123; long value = unsafe.getLongVolatile(unsafeStudy, offset); System.out.println(Thread.currentThread().getName() + "获取值为:" + value); cyclicBarrier.await(); return null; &#125;); cyclicBarrier.await(); System.out.println("第二轮测试结束"); cyclicBarrier.reset(); System.out.println("第三轮执行putOrderLong测试开始"); executorService.submit(() -&gt; &#123; unsafe.putOrderedLong(unsafeStudy, offset, 5); System.out.println(Thread.currentThread().getName() + "设置值为:" + unsafeStudy.e); cyclicBarrier.await(); return null; &#125;); executorService.submit(() -&gt; &#123; long value = unsafe.getLong(unsafeStudy, offset); System.out.println(Thread.currentThread().getName() + "获取值为:" + value); cyclicBarrier.await(); return null; &#125;); cyclicBarrier.await(); System.out.println("第三轮测试结束");&#125; park和unpark123456789101112131415161718/** * 测试park和unpark * * @param unsafe */private static void testPark(Unsafe unsafe) throws ExecutionException, InterruptedException &#123; Thread mainThread = Thread.currentThread(); ExecutorService executor = Executors.newSingleThreadExecutor(); Future&lt;Thread&gt; threadFuture = executor.submit(() -&gt; &#123; System.out.println("5s后恢复主线程" + mainThread); Thread.sleep(5000); unsafe.unpark(mainThread); return Thread.currentThread(); &#125;); System.out.println("挂起主线程:" + mainThread); unsafe.park(false, 0L); System.out.println("主线程被恢复" + mainThread);&#125; 原子更新数据123456789101112/** * 原子的增加一个值和设置一个值 * * @param unsafe * @throws NoSuchFieldException */private static void testAtomicUpdate(Unsafe unsafe) throws NoSuchFieldException &#123; UnsafeStudy unsafeStudy = new UnsafeStudy(); long offset = unsafe.objectFieldOffset(UnsafeStudy.class.getDeclaredField("b")); System.out.println(unsafe.getAndAddInt(unsafeStudy, offset, 3)); System.out.println(unsafe.getAndSetInt(unsafeStudy, offset, 1));&#125; 结语以上是Unsafe类api的使用演示,该类是许多多线程类的底层类.所以了解该类,对于学习多线程有很大收益.]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AtomicInteger源码分析]]></title>
    <url>%2F2018%2F09%2F02%2FAtomicInteger%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[概述AtomicInteger是jdk1.5之后新增的一个可以原子更新的Integer类.常用来做多线程环境下的计数器. 成员变量123456789101112131415public class AtomicInteger extends Number implements java.io.Serializable &#123; private static final long serialVersionUID = 6214790243416807050L; // setup to use Unsafe.compareAndSwapInt for updates private static final Unsafe unsafe = Unsafe.getUnsafe(); private static final long valueOffset; static &#123; try &#123; valueOffset = unsafe.objectFieldOffset (AtomicInteger.class.getDeclaredField("value")); &#125; catch (Exception ex) &#123; throw new Error(ex); &#125; &#125; private volatile int value; 可以看到共包含4个成员变量:1.value变量存放实际存储的值2.unsafe变量为sun.misc.Unsafe类的对象,该对象是AtomicInteger实现原子操作的关键.可以参考以下链接学习一下:https://blog.csdn.net/u011392897/article/details/603651453.valueOffset为通过unsafe计算出的value在内存中的偏移量.4.serivalVersionUID是序列化相关的版本信息. 构造方法1234567891011121314/** * Creates a new AtomicInteger with the given initial value. * * @param initialValue the initial value */public AtomicInteger(int initialValue) &#123; value = initialValue;&#125;/** * Creates a new AtomicInteger with initial value &#123;@code 0&#125;. */public AtomicInteger() &#123;&#125; 一个无参数构造器,会初始化value=0,有参数构造器会初始化value为参数值. api分析get方法12345678/** * Gets the current value. * * @return the current value */public final int get() &#123; return value;&#125; 普遍的获取值得方法. set方法12345678/** * Sets to the given value. * * @param newValue the new value */public final void set(int newValue) &#123; value = newValue;&#125; 普遍的设置值得方法. lazySet方法123456789/** * Eventually sets to the given value. * * @param newValue the new value * @since 1.6 */public final void lazySet(int newValue) &#123; unsafe.putOrderedInt(this, valueOffset, newValue);&#125; 性能比set方法好,但不保证立即对其他线程可见. getAndSet方法123456789/** * Atomically sets to the given value and returns the old value. * * @param newValue the new value * @return the previous value */public final int getAndSet(int newValue) &#123; return unsafe.getAndSetInt(this, valueOffset, newValue);&#125; 通过调用unsafe对象里的方法实现原子的设置值,并返回旧的值. compareAndSet方法123456789101112/** * Atomically sets the value to the given updated value * if the current value &#123;@code ==&#125; the expected value. * * @param expect the expected value * @param update the new value * @return &#123;@code true&#125; if successful. False return indicates that * the actual value was not equal to the expected value. */public final boolean compareAndSet(int expect, int update) &#123; return unsafe.compareAndSwapInt(this, valueOffset, expect, update);&#125; 仅当当前值等于期望值的时候,才重新设置值. weakCompareAndSet方法123456789101112131415/** * Atomically sets the value to the given updated value * if the current value &#123;@code ==&#125; the expected value. * * &lt;p&gt;&lt;a href="package-summary.html#weakCompareAndSet"&gt;May fail * spuriously and does not provide ordering guarantees&lt;/a&gt;, so is * only rarely an appropriate alternative to &#123;@code compareAndSet&#125;. * * @param expect the expected value * @param update the new value * @return &#123;@code true&#125; if successful */public final boolean weakCompareAndSet(int expect, int update) &#123; return unsafe.compareAndSwapInt(this, valueOffset, expect, update);&#125; 从代码角度看和compareAndSet是一样的. getAndIncrement方法12345678/** * Atomically increments by one the current value. * * @return the previous value */public final int getAndIncrement() &#123; return unsafe.getAndAddInt(this, valueOffset, 1);&#125; 原子的自增1. getAndDecrement方法12345678/** * Atomically decrements by one the current value. * * @return the previous value */public final int getAndDecrement() &#123; return unsafe.getAndAddInt(this, valueOffset, -1);&#125; 原子的自减1. getAndAdd方法123456789/** * Atomically adds the given value to the current value. * * @param delta the value to add * @return the previous value */public final int getAndAdd(int delta) &#123; return unsafe.getAndAddInt(this, valueOffset, delta);&#125; 原子的增加一个指定的值. incrementAndGet方法12345678/** * Atomically increments by one the current value. * * @return the updated value */public final int incrementAndGet() &#123; return unsafe.getAndAddInt(this, valueOffset, 1) + 1;&#125; 原子的增加1,并返回更新后的值. decrementAndGet方法12345678/** * Atomically decrements by one the current value. * * @return the updated value */public final int decrementAndGet() &#123; return unsafe.getAndAddInt(this, valueOffset, -1) - 1;&#125; 原子的自减1,并返回更新后的值. addAndGet方法123456789/** * Atomically adds the given value to the current value. * * @param delta the value to add * @return the updated value */public final int addAndGet(int delta) &#123; return unsafe.getAndAddInt(this, valueOffset, delta) + delta;&#125; 原子的增加一个指定的值,并返回更新后的值. getAndUpdate方法123456789101112131415161718/** * Atomically updates the current value with the results of * applying the given function, returning the previous value. The * function should be side-effect-free, since it may be re-applied * when attempted updates fail due to contention among threads. * * @param updateFunction a side-effect-free function * @return the previous value * @since 1.8 */public final int getAndUpdate(IntUnaryOperator updateFunction) &#123; int prev, next; do &#123; prev = get(); next = updateFunction.applyAsInt(prev); &#125; while (!compareAndSet(prev, next)); return prev;&#125; 使用参数传入的函数接口来更新当前值,更新失败会重试,返回更新之前的值. updateAndGet方法123456789101112131415161718/** * Atomically updates the current value with the results of * applying the given function, returning the updated value. The * function should be side-effect-free, since it may be re-applied * when attempted updates fail due to contention among threads. * * @param updateFunction a side-effect-free function * @return the updated value * @since 1.8 */public final int updateAndGet(IntUnaryOperator updateFunction) &#123; int prev, next; do &#123; prev = get(); next = updateFunction.applyAsInt(prev); &#125; while (!compareAndSet(prev, next)); return next;&#125; 根据传入的函数接口更新当前值,并返回更新后的值. getAndAccumulate方法1234567891011121314151617181920212223/** * Atomically updates the current value with the results of * applying the given function to the current and given values, * returning the previous value. The function should be * side-effect-free, since it may be re-applied when attempted * updates fail due to contention among threads. The function * is applied with the current value as its first argument, * and the given update as the second argument. * * @param x the update value * @param accumulatorFunction a side-effect-free function of two arguments * @return the previous value * @since 1.8 */public final int getAndAccumulate(int x, IntBinaryOperator accumulatorFunction) &#123; int prev, next; do &#123; prev = get(); next = accumulatorFunction.applyAsInt(prev, x); &#125; while (!compareAndSet(prev, next)); return prev;&#125; 根据传入的int值和函数接口,计算更新后的值,并返回更新前的值. accumulateAndGet方法1234567891011121314151617181920212223/** * Atomically updates the current value with the results of * applying the given function to the current and given values, * returning the updated value. The function should be * side-effect-free, since it may be re-applied when attempted * updates fail due to contention among threads. The function * is applied with the current value as its first argument, * and the given update as the second argument. * * @param x the update value * @param accumulatorFunction a side-effect-free function of two arguments * @return the updated value * @since 1.8 */public final int accumulateAndGet(int x, IntBinaryOperator accumulatorFunction) &#123; int prev, next; do &#123; prev = get(); next = accumulatorFunction.applyAsInt(prev, x); &#125; while (!compareAndSet(prev, next)); return next;&#125; 通过传入的int值和函数接口,更新当前值,并返回更新后的值. toString方法1234567/** * Returns the String representation of the current value. * @return the String representation of the current value */public String toString() &#123; return Integer.toString(get());&#125; 返回当前值得字符串表示. intValue方法123456/** * Returns the value of this &#123;@code AtomicInteger&#125; as an &#123;@code int&#125;. */public int intValue() &#123; return get();&#125; 返回当前值的int表示. longValue方法12345678/** * Returns the value of this &#123;@code AtomicInteger&#125; as a &#123;@code long&#125; * after a widening primitive conversion. * @jls 5.1.2 Widening Primitive Conversions */public long longValue() &#123; return (long)get();&#125; 返回当前值的long表示. floatValue方法12345678/** * Returns the value of this &#123;@code AtomicInteger&#125; as a &#123;@code float&#125; * after a widening primitive conversion. * @jls 5.1.2 Widening Primitive Conversions */public float floatValue() &#123; return (float)get();&#125; 返回当前值的float表示. doubleValue方法12345678/** * Returns the value of this &#123;@code AtomicInteger&#125; as a &#123;@code double&#125; * after a widening primitive conversion. * @jls 5.1.2 Widening Primitive Conversions */public double doubleValue() &#123; return (double)get();&#125; 返回当前值的double表示.]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决Map缓存问题]]></title>
    <url>%2F2018%2F08%2F25%2Fjava%E7%BC%93%E5%AD%98Map%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[概述使用java自带的HashMap和ConcurrentHashMap可以做应用程序缓存,但直接使用会导致内存无限增长,产生OOM异常. 解决办法使用软引用和虚引用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.lang.ref.SoftReference;import java.util.Objects;import java.util.concurrent.ConcurrentHashMap;/** * 功能描述: 使用软引用改进Map缓存 * * @author sunzhiqiang * @create 2018-08-25 */public class SoftReferenceMap&lt;K, V&gt; &#123; private final ConcurrentHashMap&lt;SoftReference&lt;K&gt;, SoftReference&lt;V&gt;&gt; cache = new ConcurrentHashMap&lt;&gt;(); public V get(K k) &#123; Objects.requireNonNull(k); SoftReference&lt;K&gt; key = new SoftReference&lt;&gt;(k); SoftReference&lt;V&gt; value = cache.get(key); return value == null ? null : value.get(); &#125; public V put(K k, V v) &#123; Objects.requireNonNull(k); Objects.requireNonNull(v); SoftReference&lt;K&gt; key = new SoftReference&lt;&gt;(k); SoftReference&lt;V&gt; value = new SoftReference&lt;&gt;(v); SoftReference&lt;V&gt; oldValue = cache.put(key, value); return oldValue == null ? null : oldValue.get(); &#125; public V remove(K k) &#123; Objects.requireNonNull(k); SoftReference&lt;K&gt; key = new SoftReference&lt;&gt;(k); SoftReference&lt;V&gt; oldValue = cache.remove(key); return oldValue == null ? null : oldValue.get(); &#125;&#125; 使用LRUMap1234567891011121314151617181920212223242526272829303132333435import java.util.LinkedHashMap;import java.util.Map;/** * 功能描述: 最近最少使用Map * * @author sunzhiqiang * @create 2018-08-25 */public class LRUMap&lt;K, V&gt; extends LinkedHashMap&lt;K, V&gt; &#123; private final int max; public LRUMap(int max) &#123; super((int) (max * 1.4f), 0.75f, true); this.max = max; &#125; @Override protected boolean removeEldestEntry(Map.Entry&lt;K, V&gt; eldest) &#123; return size() &gt; max; &#125; public synchronized V getValue(K k) &#123; return get(k); &#125; public synchronized V putValue(K k, V v) &#123; return put(k, v); &#125; public synchronized boolean removeValue(K k, V v) &#123; return remove(k, v); &#125;&#125; 使用guava cache1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import com.google.common.cache.CacheBuilder;import com.google.common.cache.CacheLoader;import com.google.common.cache.LoadingCache;import java.util.concurrent.ExecutionException;import java.util.concurrent.TimeUnit;/** * 功能描述: 使用guava cache * * @author sunzhiqiang * @create 2018-08-25 */public class GuavaCacheMap&lt;K, V&gt; &#123; private LoadingCache&lt;K, V&gt; cache = null; public GuavaCacheMap() &#123; cacheInit(); &#125; private void cacheInit() &#123; cache = CacheBuilder.newBuilder() .maximumSize(100) .expireAfterWrite(30L, TimeUnit.SECONDS) .expireAfterAccess(30L, TimeUnit.SECONDS) .refreshAfterWrite(20L, TimeUnit.SECONDS) .weakKeys() .build(new CacheLoader&lt;K, V&gt;() &#123; @Override public V load(K k) throws Exception &#123; return null; &#125; &#125;); &#125; public V get(K k) throws ExecutionException &#123; return cache.get(k); &#125; public void put(K k, V v) &#123; cache.put(k, v); &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[零拷贝]]></title>
    <url>%2F2018%2F08%2F19%2F%E9%9B%B6%E6%8B%B7%E8%B4%9D%2F</url>
    <content type="text"><![CDATA[概念 零拷贝的“零”是指用户态和内核态间copy数据的次数为零。传统的数据copy（文件到文件、client到server等）涉及到四次用户态内核态切换、四次copy。四次copy中，两次在用户态和内核态间copy需要CPU参与、两次在内核态与IO设备间copy为DMA方式不需要CPU参与。零拷贝避免了用户态和内核态间的copy、减少了两次用户态内核态间的切换。 java零拷贝apitransferTo123456789101112131415private static void copyByTransferTo() throws IOException &#123; //FileChannel fromChannel = new FileInputStream(ZeroCopyStudy.class.getResource("/source.txt").getFile()).getChannel(); FileChannel fromChannel = new FileInputStream("D:/video/a.avi").getChannel(); FileChannel toChannel = new FileOutputStream("copy.txt").getChannel(); long startTime = System.nanoTime(); fromChannel.transferTo(0, fromChannel.size(), toChannel); System.out.println("transferTo:" + (System.nanoTime() - startTime)/1000000000.0); fromChannel.close(); toChannel.close(); Files.deleteIfExists(Paths.get("copy.txt"));&#125; 123456789101112131415private static void copyByTransferToUseAccessFile() throws IOException &#123; //FileChannel fromChannel = new RandomAccessFile(ZeroCopyStudy.class.getResource("/source.txt").getFile(),"rw").getChannel(); FileChannel fromChannel = new RandomAccessFile("D:/video/a.avi","rw").getChannel(); FileChannel toChannel = new RandomAccessFile("copy.txt","rw").getChannel(); long startTime = System.nanoTime(); fromChannel.transferTo(0, fromChannel.size(), toChannel); System.out.println("randomAccessFile:" + (System.nanoTime() - startTime)/1000000000.0); fromChannel.close(); toChannel.close(); Files.deleteIfExists(Paths.get("copy.txt"));&#125; transferFrom123456789101112131415private static void copyByTransferFrom() throws IOException &#123; // FileChannel fromChannel = new FileInputStream(ZeroCopyStudy.class.getResource("/source.txt").getFile()).getChannel(); FileChannel fromChannel = new FileInputStream("D:/video/a.avi").getChannel(); FileChannel toChannel = new FileOutputStream("copy.txt").getChannel(); long startTime = System.nanoTime(); toChannel.transferFrom(fromChannel,0,fromChannel.size()); System.out.println("transferFrom:" + (System.nanoTime() - startTime)/1000000000.0); fromChannel.close(); toChannel.close(); Files.deleteIfExists(Paths.get("copy.txt"));&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原型模式]]></title>
    <url>%2F2018%2F08%2F19%2F%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[模式定义用原型实例指定创建对象的种类,并通过复制这些原型创建新的对象. 代码演示抽象原型123456789101112/** * 功能描述: 抽象原型 * * @author sunzhiqiang * @create 2018-08-19 */public interface Prototype extends Cloneable, Serializable &#123; Object getObjectByClone() throws CloneNotSupportedException; Object getObjectBySerializable() throws IOException, ClassNotFoundException;&#125; 具体原型12345678910111213141516171819202122232425262728293031323334353637383940/** * 功能描述: 具体原型 * * @author sunzhiqiang * @create 2018-08-19 */public class PersonComputer implements Prototype &#123; String cpu; String ram; @Override public Object getObjectByClone() throws CloneNotSupportedException&#123; Object obj = clone(); return obj; &#125; @Override public Object getObjectBySerializable() throws IOException, ClassNotFoundException &#123; ByteArrayOutputStream out = new ByteArrayOutputStream(); ObjectOutputStream objOut = new ObjectOutputStream(out); objOut.writeObject(this); ByteArrayInputStream in = new ByteArrayInputStream(out.toByteArray()); ObjectInputStream objIn = new ObjectInputStream(in); Object obj = objIn.readObject(); return obj; &#125; /* * 继续使用protected修饰,不对外界直接暴露,让外界的程序通过getObject来使用原型模式 */ @Override protected Object clone() throws CloneNotSupportedException &#123; return super.clone(); &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生成器模式(建造者模式)]]></title>
    <url>%2F2018%2F08%2F18%2F%E7%94%9F%E6%88%90%E5%99%A8%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[模式定义将一个复杂对象的构建与它的表示分离,使同样的构建过程可以产生不同的表示. 代码演示具体产品12345678910111213141516/** * 功能描述: 具体产品 * * @author sunzhiqiang * @create 2018-08-18 */public class Computer &#123; String cpu; String ram; String hardDisk; String motherboard;&#125; 抽象构建器123456789101112131415161718/** * 功能描述: 抽象构建器 * * @author sunzhiqiang * @create 2018-08-18 */public interface ComputerBuilder &#123; ComputerBuilder buildCPU(String cpu); ComputerBuilder buildRAM(String ram); ComputerBuilder buildHardDisk(String hardDisk); ComputerBuilder buildMotherBoard(String motherBoard); Computer build();&#125; 具体构建器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * 功能描述: 具体构建器 * * @author sunzhiqiang * @create 2018-08-18 */public class MacComputerBuilder implements ComputerBuilder &#123; private Computer computer; public MacComputerBuilder(Computer computer)&#123; this.computer = computer; &#125; @Override public ComputerBuilder buildCPU(String cpu) &#123; computer.cpu = cpu; return this; &#125; @Override public ComputerBuilder buildRAM(String ram) &#123; computer.ram = ram; return this; &#125; @Override public ComputerBuilder buildHardDisk(String hardDisk) &#123; computer.hardDisk = hardDisk; return this; &#125; @Override public ComputerBuilder buildMotherBoard(String motherBoard) &#123; computer.motherboard = motherBoard; return this; &#125; @Override public Computer build() &#123; return computer; &#125;&#125; 指挥者1234567891011121314151617181920212223/** * 功能描述: 指挥者 * * @author sunzhiqiang * @create 2018-08-18 */public class Director &#123; private ComputerBuilder builder; public Director(ComputerBuilder builder) &#123; this.builder = builder; &#125; public Computer buildComputer() &#123; return builder.buildCPU("Mac的CPU") .buildRAM("Mac的内存") .buildHardDisk("Mac的硬盘") .buildMotherBoard("Mac的主板") .build(); &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[抽象工厂模式]]></title>
    <url>%2F2018%2F08%2F18%2F%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[模式定义提供一个创建一系列或相互依赖对象的接口,而无须指定它们具体的类. 代码演示抽象产品抽象手机12345678910/** * 功能描述: 抽象产品 * * @author sunzhiqiang * @create 2018-08-18 */public interface Phone &#123; void phoneMessage();&#125; 抽象手机充电器12345678910/** * 功能描述: 抽象产品 * * @author sunzhiqiang * @create 2018-08-18 */public interface Charger &#123; void chargerMessage();&#125; 具体产品IOS手机1234567891011121314/** * 功能描述: 具体产品 * * @author sunzhiqiang * @create 2018-08-18 */public class IOSPhone implements Phone &#123; @Override public void phoneMessage() &#123; System.out.println("这是苹果手机."); &#125;&#125; 安卓手机1234567891011121314/** * 功能描述: 具体产品 * * @author sunzhiqiang * @create 2018-08-18 */public class AndroidPhone implements Phone &#123; @Override public void phoneMessage() &#123; System.out.println("这是安卓手机."); &#125;&#125; IOS充电器1234567891011121314/** * 功能描述: 具体产品 * * @author sunzhiqiang * @create 2018-08-18 */public class IOSCharger implements Charger &#123; @Override public void chargerMessage() &#123; System.out.println("这是苹果手机充电器"); &#125;&#125; 安卓手机充电器1234567891011121314/** * 功能描述: 具体产品 * * @author sunzhiqiang * @create 2018-08-18 */public class AndroidCharger implements Charger &#123; @Override public void chargerMessage() &#123; System.out.println("这是安卓手机充电器."); &#125;&#125; 抽象工厂手机产品工厂123456789101112/** * 功能描述: 抽象工厂 * * @author sunzhiqiang * @create 2018-08-18 */public interface PhoneProductFactory &#123; Phone getPhone(); Charger getCharger();&#125; 具体工厂IOS手机产品工厂1234567891011121314151617181920/** * 功能描述: 具体工厂 * * @author sunzhiqiang * @create 2018-08-18 */public class IOSPhoneProductFactory implements PhoneProductFactory&#123; @Override public Phone getPhone() &#123; return new IOSPhone(); &#125; @Override public Charger getCharger() &#123; return new IOSCharger(); &#125;&#125; 安卓手机产品工厂1234567891011121314151617181920/** * 功能描述: 具体工厂 * * @author sunzhiqiang * @create 2018-08-18 */public class AndriodPhoneProductFactory implements PhoneProductFactory &#123; @Override public Phone getPhone() &#123; return new AndroidPhone(); &#125; @Override public Charger getCharger() &#123; return new AndroidCharger(); &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工厂方法模式]]></title>
    <url>%2F2018%2F08%2F18%2F%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[模式定义定义一个用于创建对象的接口,让子类决定实例化哪一个类.Factory Method使一个类的实例化延迟到其子类. 代码演示抽象产品抽象产品为电脑类12345678910/** * 功能描述: 抽象产品 * * @author sunzhiqiang * @create 2018-08-18 */public interface Computer &#123; void run();&#125; 抽象工厂抽象工厂为电脑工厂类12345678910/** * 功能描述: 工厂接口 * * @author sunzhiqiang * @create 2018-08-18 */public interface ComputerFactory &#123; Computer getComputer();&#125; 具体产品个人电脑1234567891011121314/** * 功能描述: 具体产品 * * @author sunzhiqiang * @create 2018-08-18 */public class PersonComputer implements Computer &#123; @Override public void run() &#123; System.out.println("个人电脑正在运行..."); &#125;&#125; 服务器1234567891011121314/** * 功能描述: 具体产品 * * @author sunzhiqiang * @create 2018-08-18 */public class Server implements Computer &#123; @Override public void run() &#123; System.out.println("服务器正在运行..."); &#125;&#125; 具体工厂个人电脑工厂1234567891011121314/** * 功能描述: 具体工厂类 * * @author sunzhiqiang * @create 2018-08-18 */public class PersonComputerFactory implements ComputerFactory&#123; @Override public Computer getComputer() &#123; return new PersonComputer(); &#125;&#125; 服务器工厂1234567891011121314/** * 功能描述: 具体工厂 * * @author sunzhiqiang * @create 2018-08-18 */public class ServerFactory implements ComputerFactory &#123; @Override public Computer getComputer() &#123; return new Server(); &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java特殊对象]]></title>
    <url>%2F2018%2F08%2F17%2FJava%E7%89%B9%E6%AE%8A%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[概述java为了节省内存,会缓存部分常用数据来避免频繁创造对象. String缓存静态创建和new创建String是java.lang包下的字符串类,底层实现使用享元模式,共享对象.123456789101112@Testpublic void test1()&#123; String s1 = "aaa"; String s2 = "aaa"; String s3 = new String("aaa"); String s4 = new String("aaa"); System.out.println(s1 == s2); // true System.out.println(s1 == s3); // false System.out.println(s3 == s4); // false&#125; 要解释上面的结果,这里首先要说明一下的是String的2种创建方式:1.静态创建1String s1 = "aaa"; 2.通过new关键字进行创建1String s3 = new String("aaa"); 当字符串使用静态创建时,会在字符串缓冲区中创建对象,然后把对象的引用返回.当下次通过静态创建方式创建相同字符串是,会直接返回字符串缓存区中对象的引用,这正是享元模式的应用.当字符串对象通过new关键字进行创建时,会在堆空间分配内存.所以每次都会使用不同的内存. intern方法String类的intern方法可以把通过new创建的对象复制一份到字符串常量池.1234567891011@Testpublic void test2()&#123; String s1 = "aaa"; String s2 = new String("aaa"); String s3 = s2.intern(); System.out.println(s1 == s2); // false System.out.println(s1 == s3); // true System.out.println(s2 == s3); // false&#125; Integer缓存Integer类是基本数据类型int的包装类,因为比较常用,Java对-128到127的数据会缓存起来,重复利用.123456789101112131415161718192021222324@Testpublic void test1()&#123; Integer a = 1; Integer b = 1; Integer c = 128; Integer d = 128; Integer e = new Integer(1); Integer f = -1; Integer g = -1; Integer h = -128; Integer i = -128; Integer k = Integer.valueOf(1); System.out.println(a == b); // true System.out.println(c == d); // false System.out.println(a == e); // false System.out.println(f == g); // true System.out.println(h == i); // true System.out.println(a == k); // true&#125; 当使用Integer a = 1的方式创建Integer对象时,实际上是在调用Integer.valueOf(int)方法,该方法会检查参数值得大小,当参数落在-128到127的范围,就返回JVM事先创建好的对象.否则重新创建对象.使用new关键字每次都会重新创建对象.]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lambda表达式]]></title>
    <url>%2F2018%2F08%2F17%2Flambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[概述 Lambda 表达式，也可称为闭包，它是推动 Java 8 发布的最重要新特性。Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中）。使用 Lambda 表达式可以使代码变的更加简洁紧凑。 使用代替匿名内部类使用lambda表达式实现runnable接口12345678910111213141516171819@Testpublic void testLambda1() throws Exception &#123; Thread thread = new Thread(() -&gt; &#123; try &#123; Thread.sleep(1000); System.out.println("lambda表达式实现runnable接口"); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125;); thread.start(); System.out.println("主线程开始"); thread.join(); System.out.println("主线程结束");&#125; 使用函数接口使用lambda实现集合遍历123456789@Testpublic void testLambda2()&#123; List&lt;Integer&gt; list = Arrays.asList(1,2,3,4,5); list.forEach(s -&gt; &#123; System.out.println(s); &#125;);&#125; 使用自定义的函数接口使用lambda表达式实现自定义的函数接口.123456789101112131415161718private interface MyFunction&lt;R,P&gt;&#123; R getRusult(P p);&#125;private &lt;R,P&gt; void method(MyFunction&lt;R,P&gt; function)&#123; String result = "result"; System.out.println(function.getRusult((P) result));&#125;@Testpublic void testLambda3()&#123; method(p -&gt; &#123; return p; &#125;);&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[享元模式]]></title>
    <url>%2F2018%2F08%2F15%2F%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[模式的定义运用共享技术有效地支持大量细粒度的对象. 代码演示享元接口1234567891011/** * 功能描述: 享元模式 * 享元接口 * * @author sunzhiqiang * @create 2018-08-15 */public interface FlyWeight &#123; void opration(String extrinsicState);&#125; 具体享元对象123456789101112131415161718192021/** * 功能描述: 享元模式 * 具体享元 * * @author sunzhiqiang * @create 2018-08-15 */class ConcreteFlyWeight implements FlyWeight &#123; private String intrinsicState; public ConcreteFlyWeight(String intrinsicState) &#123; this.intrinsicState = intrinsicState; &#125; @Override public void opration(String extrinsicState) &#123; System.out.println(intrinsicState + extrinsicState); &#125;&#125; 享元工厂123456789101112131415161718192021222324252627282930313233/** * 功能描述: 享元模式 * 享元工厂 * * @author sunzhiqiang * @create 2018-08-15 */public final class FlyWeightFactory &#123; private static final FlyWeightFactory FACTORY = new FlyWeightFactory(); private final ConcurrentHashMap&lt;String,SoftReference&lt;FlyWeight&gt;&gt; cache = new ConcurrentHashMap&lt;&gt;(); private FlyWeightFactory() &#123; &#125; public static FlyWeightFactory factory() &#123; return FACTORY; &#125; public FlyWeight getFlyWeight(String key)&#123; if(cache.get(key) != null)&#123; return cache.get(key).get(); &#125;else&#123; FlyWeight flyWeight = new ConcreteFlyWeight(key); cache.putIfAbsent(key,new SoftReference&lt;&gt;(flyWeight)); return flyWeight; &#125; &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Objects源码分析]]></title>
    <url>%2F2018%2F08%2F14%2FObjects%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[概述java.util.Objects是JDK1.7后新增的用来操作Object常见方法的工具类. 源码跟踪equals方法源码展示123456789101112131415161718/** * Returns &#123;@code true&#125; if the arguments are equal to each other * and &#123;@code false&#125; otherwise. * Consequently, if both arguments are &#123;@code null&#125;, &#123;@code true&#125; * is returned and if exactly one argument is &#123;@code null&#125;, &#123;@code * false&#125; is returned. Otherwise, equality is determined by using * the &#123;@link Object#equals equals&#125; method of the first * argument. * * @param a an object * @param b an object to be compared with &#123;@code a&#125; for equality * @return &#123;@code true&#125; if the arguments are equal to each other * and &#123;@code false&#125; otherwise * @see Object#equals(Object) */public static boolean equals(Object a, Object b) &#123; return (a == b) || (a != null &amp;&amp; a.equals(b));&#125; 测试代码1234567891011121314151617181920212223@Testpublic void testEquals()&#123; String str1 = "aaa"; String str2 = new String("aaa"); System.out.println(str1.equals(str2)); // true System.out.println(Objects.equals(str1,str2)); // true Integer integer1 = 1; Integer integer2 = 1; System.out.println(integer1.equals(integer2)); // true System.out.println(Objects.equals(integer1,integer2)); // true Integer integer3 = 128; Integer integer4 = 128; System.out.println(integer3.equals(integer4)); // true System.out.println(Objects.equals(integer3,integer4)); // true MyObjects myObjects1 = new MyObjects(); MyObjects myObjects2 = new MyObjects(); System.out.println(myObjects1.equals(myObjects2)); // false System.out.println(Objects.equals(myObjects1,myObjects2)); // false&#125; 结论Objects.equals(Object,Object)方法与Object.equals(Object)方法作用相同,但增加了空值判断,代码更加健壮. deepEquals方法源码展示12345678910111213141516171819202122232425/** * Returns &#123;@code true&#125; if the arguments are deeply equal to each other * and &#123;@code false&#125; otherwise. * * Two &#123;@code null&#125; values are deeply equal. If both arguments are * arrays, the algorithm in &#123;@link Arrays#deepEquals(Object[], * Object[]) Arrays.deepEquals&#125; is used to determine equality. * Otherwise, equality is determined by using the &#123;@link * Object#equals equals&#125; method of the first argument. * * @param a an object * @param b an object to be compared with &#123;@code a&#125; for deep equality * @return &#123;@code true&#125; if the arguments are deeply equal to each other * and &#123;@code false&#125; otherwise * @see Arrays#deepEquals(Object[], Object[]) * @see Objects#equals(Object, Object) */ public static boolean deepEquals(Object a, Object b) &#123; if (a == b) return true; else if (a == null || b == null) return false; else return Arrays.deepEquals0(a, b); &#125; 测试代码12345678910111213@Testpublic void testDeepEquals()&#123; // 比较2个对象的值是不是相等 String str1 = "aaa"; String str2 = new String("aaa"); System.out.println(Objects.deepEquals(str1,str2)); // true // 比较2个对象数组所存储的值是不是相等 String[] strArray1 = new String[]&#123;"aaa","bbb","ccc"&#125;; String[] strArray2 = new String[]&#123;new String("aaa"),new String("bbb"),new String("ccc")&#125;; System.out.println(Objects.deepEquals(strArray1,strArray2)); // true&#125; 结论Objects.deepEquals(Object,Object)方法,当传入的2个参数都是普通对象时,等同于Objects.equals(Object,Object);当传入的2个参数都是数组对象时,等同于Arrays.deepEquals(Object[],Object[]) hashcode方法源码展示123456789101112/** * Returns the hash code of a non-&#123;@code null&#125; argument and 0 for * a &#123;@code null&#125; argument. * * @param o an object * @return the hash code of a non-&#123;@code null&#125; argument and 0 for * a &#123;@code null&#125; argument * @see Object#hashCode */public static int hashCode(Object o) &#123; return o != null ? o.hashCode() : 0;&#125; 测试代码123456789@Testpublic void testHashCode()&#123; String str1 = null; String str2 = "aaa"; System.out.println(Objects.hashCode(str1)); // 0 System.out.println(str2.hashCode()); // 96321 System.out.println(Objects.hashCode(str2)); // 96321&#125; 结论Objects.hashCode(Object)与Object.hashCode()方法作用相同,但增加了空值判断,代码更加健壮. hash方法源码展示1234567891011121314151617181920212223242526272829/** * Generates a hash code for a sequence of input values. The hash * code is generated as if all the input values were placed into an * array, and that array were hashed by calling &#123;@link * Arrays#hashCode(Object[])&#125;. * * &lt;p&gt;This method is useful for implementing &#123;@link * Object#hashCode()&#125; on objects containing multiple fields. For * example, if an object that has three fields, &#123;@code x&#125;, &#123;@code * y&#125;, and &#123;@code z&#125;, one could write: * * &lt;blockquote&gt;&lt;pre&gt; * &amp;#064;Override public int hashCode() &#123; * return Objects.hash(x, y, z); * &#125; * &lt;/pre&gt;&lt;/blockquote&gt; * * &lt;b&gt;Warning: When a single object reference is supplied, the returned * value does not equal the hash code of that object reference.&lt;/b&gt; This * value can be computed by calling &#123;@link #hashCode(Object)&#125;. * * @param values the values to be hashed * @return a hash value of the sequence of input values * @see Arrays#hashCode(Object[]) * @see List#hashCode */ public static int hash(Object... values) &#123; return Arrays.hashCode(values); &#125; 测试代码1234567@Testpublic void testHash()&#123; String[] strArray = new String[]&#123;"aaa","bbb","ccc"&#125;; System.out.println(Arrays.hashCode(strArray)); // 95709313 System.out.println(Objects.hash(strArray)); // 95709313&#125; 结论Objects.hash(Object[])与Arrays.hashCode(Object[])作用完全相同. toString方法源码展示12345678910111213/** * Returns the result of calling &#123;@code toString&#125; for a non-&#123;@code * null&#125; argument and &#123;@code "null"&#125; for a &#123;@code null&#125; argument. * * @param o an object * @return the result of calling &#123;@code toString&#125; for a non-&#123;@code * null&#125; argument and &#123;@code "null"&#125; for a &#123;@code null&#125; argument * @see Object#toString * @see String#valueOf(Object) */public static String toString(Object o) &#123; return String.valueOf(o);&#125; 测试代码1234567891011@Testpublic void testToString()&#123; Integer integer = 200; System.out.println(integer.toString()); // 200 System.out.println(Objects.toString(integer)); // 200 MyObjects myObjects = new MyObjects(); System.out.println(myObjects.toString()); // cn.com.sunzhiqiang.java.objects.MyObjects@1794d431 System.out.println(Objects.toString(myObjects)); // cn.com.sunzhiqiang.java.objects.MyObjects@1794d431&#125; 结论Objects.toString(Object)和Object.toString()实现功能基本相同. 带默认值toString方法源码展示12345678910111213141516/** * Returns the result of calling &#123;@code toString&#125; on the first * argument if the first argument is not &#123;@code null&#125; and returns * the second argument otherwise. * * @param o an object * @param nullDefault string to return if the first argument is * &#123;@code null&#125; * @return the result of calling &#123;@code toString&#125; on the first * argument if it is not &#123;@code null&#125; and the second argument * otherwise. * @see Objects#toString(Object) */public static String toString(Object o, String nullDefault) &#123; return (o != null) ? o.toString() : nullDefault;&#125; 测试代码12345678@Testpublic void testToStringHasDefaultValue()&#123; String str1 = null; String str2 = "bbb"; System.out.println(Objects.toString(str1,"aaa")); // aaa System.out.println(Objects.toString(str2,"aaa")); // bbb&#125; 结论Objects.toString(Object,String)当参数Object为空时,返回String参数的值,否则返回Object.toString(). compare方法源码展示1234567891011121314151617181920212223/** * Returns 0 if the arguments are identical and &#123;@code * c.compare(a, b)&#125; otherwise. * Consequently, if both arguments are &#123;@code null&#125; 0 * is returned. * * &lt;p&gt;Note that if one of the arguments is &#123;@code null&#125;, a &#123;@code * NullPointerException&#125; may or may not be thrown depending on * what ordering policy, if any, the &#123;@link Comparator Comparator&#125; * chooses to have for &#123;@code null&#125; values. * * @param &lt;T&gt; the type of the objects being compared * @param a an object * @param b an object to be compared with &#123;@code a&#125; * @param c the &#123;@code Comparator&#125; to compare the first two arguments * @return 0 if the arguments are identical and &#123;@code * c.compare(a, b)&#125; otherwise. * @see Comparable * @see Comparator */public static &lt;T&gt; int compare(T a, T b, Comparator&lt;? super T&gt; c) &#123; return (a == b) ? 0 : c.compare(a, b);&#125; 测试代码1234567891011121314151617@Testpublic void testCompare() &#123; Integer a = 6; Integer b = 8; System.out.println(Objects.compare(a, b, new Comparator&lt;Integer&gt;() &#123; @Override public int compare(Integer o1, Integer o2) &#123; if(o1 &gt; o2) return 1; if(o1 &lt; o2) return -1; return 0; &#125; &#125;)); // -1&#125; 结论Objects.compare(T,T,Comparator&lt;? super T&gt;)方法可以通过自定义比较器进行2个元素的比较. requireNonNull方法源码展示1234567891011121314151617181920/** * Checks that the specified object reference is not &#123;@code null&#125;. This * method is designed primarily for doing parameter validation in methods * and constructors, as demonstrated below: * &lt;blockquote&gt;&lt;pre&gt; * public Foo(Bar bar) &#123; * this.bar = Objects.requireNonNull(bar); * &#125; * &lt;/pre&gt;&lt;/blockquote&gt; * * @param obj the object reference to check for nullity * @param &lt;T&gt; the type of the reference * @return &#123;@code obj&#125; if not &#123;@code null&#125; * @throws NullPointerException if &#123;@code obj&#125; is &#123;@code null&#125; */public static &lt;T&gt; T requireNonNull(T obj) &#123; if (obj == null) throw new NullPointerException(); return obj;&#125; 测试代码12345678@Testpublic void testRequireNonNull()&#123; String str = null; String str2 = "abc"; System.out.println(Objects.requireNonNull(str)); // java.lang.NullPointerException System.out.println(Objects.requireNonNull(str2)); // abc&#125; 结论Objects.requireNonNull(T)可以用来检查参数是否为空,在JDK源码里,大量使用它来检查输入参数的合法性. 带默认信息的requireNonNull方法源码展示123456789101112131415161718192021222324/** * Checks that the specified object reference is not &#123;@code null&#125; and * throws a customized &#123;@link NullPointerException&#125; if it is. This method * is designed primarily for doing parameter validation in methods and * constructors with multiple parameters, as demonstrated below: * &lt;blockquote&gt;&lt;pre&gt; * public Foo(Bar bar, Baz baz) &#123; * this.bar = Objects.requireNonNull(bar, "bar must not be null"); * this.baz = Objects.requireNonNull(baz, "baz must not be null"); * &#125; * &lt;/pre&gt;&lt;/blockquote&gt; * * @param obj the object reference to check for nullity * @param message detail message to be used in the event that a &#123;@code * NullPointerException&#125; is thrown * @param &lt;T&gt; the type of the reference * @return &#123;@code obj&#125; if not &#123;@code null&#125; * @throws NullPointerException if &#123;@code obj&#125; is &#123;@code null&#125; */public static &lt;T&gt; T requireNonNull(T obj, String message) &#123; if (obj == null) throw new NullPointerException(message); return obj;&#125; 测试代码12345678@Testpublic void testRequireNotNullHasDefaultMessage()&#123; String str = null; String str2 = "abc"; System.out.println(Objects.requireNonNull(str,"参数不能为空")); // java.lang.NullPointerException: 参数不能为空 System.out.println(Objects.requireNonNull(str2,"参数不能为空")); // abc&#125; 结论Objects.requireNotNull(T,String)在检查输入参数是否为空的同时提供了,当为空的时候,指定异常信息的功能. isNull方法源码展示1234567891011121314151617/** * Returns &#123;@code true&#125; if the provided reference is &#123;@code null&#125; otherwise * returns &#123;@code false&#125;. * * @apiNote This method exists to be used as a * &#123;@link java.util.function.Predicate&#125;, &#123;@code filter(Objects::isNull)&#125; * * @param obj a reference to be checked against &#123;@code null&#125; * @return &#123;@code true&#125; if the provided reference is &#123;@code null&#125; otherwise * &#123;@code false&#125; * * @see java.util.function.Predicate * @since 1.8 */public static boolean isNull(Object obj) &#123; return obj == null;&#125; 测试代码12345678@Testpublic void testIsNull()&#123; String str = null; String str2 = "abc"; System.out.println(Objects.isNull(str)); // true System.out.println(Objects.isNull(str2)); // false&#125; 结论Object.isNull(Object)方法可以判断输入参数是否为空,感觉有点鸡肋. nonNull方法源码展示1234567891011121314151617/** * Returns &#123;@code true&#125; if the provided reference is non-&#123;@code null&#125; * otherwise returns &#123;@code false&#125;. * * @apiNote This method exists to be used as a * &#123;@link java.util.function.Predicate&#125;, &#123;@code filter(Objects::nonNull)&#125; * * @param obj a reference to be checked against &#123;@code null&#125; * @return &#123;@code true&#125; if the provided reference is non-&#123;@code null&#125; * otherwise &#123;@code false&#125; * * @see java.util.function.Predicate * @since 1.8 */public static boolean nonNull(Object obj) &#123; return obj != null;&#125; 测试代码12345678@Testpublic void testNonNull() &#123; String str = null; String str2 = "abc"; System.out.println(Objects.nonNull(str)); // false System.out.println(Objects.nonNull(str2)); // true&#125; 结论判断是不是非空,同isNull方法一样,有点鸡肋. 带函数接口的requireNonNull方法源码展示12345678910111213141516171819202122232425/** * Checks that the specified object reference is not &#123;@code null&#125; and * throws a customized &#123;@link NullPointerException&#125; if it is. * * &lt;p&gt;Unlike the method &#123;@link #requireNonNull(Object, String)&#125;, * this method allows creation of the message to be deferred until * after the null check is made. While this may confer a * performance advantage in the non-null case, when deciding to * call this method care should be taken that the costs of * creating the message supplier are less than the cost of just * creating the string message directly. * * @param obj the object reference to check for nullity * @param messageSupplier supplier of the detail message to be * used in the event that a &#123;@code NullPointerException&#125; is thrown * @param &lt;T&gt; the type of the reference * @return &#123;@code obj&#125; if not &#123;@code null&#125; * @throws NullPointerException if &#123;@code obj&#125; is &#123;@code null&#125; * @since 1.8 */public static &lt;T&gt; T requireNonNull(T obj, Supplier&lt;String&gt; messageSupplier) &#123; if (obj == null) throw new NullPointerException(messageSupplier.get()); return obj;&#125; 测试代码123456789101112@Testpublic void testRequireNonNullHasFunctionInterface()&#123; String str = null; String str2 = "abc"; System.out.println(Objects.requireNonNull(str,() -&gt; &#123; return "参数不能为空"; &#125;)); //return java.lang.NullPointerException: 参数不能为空 System.out.println(Objects.requireNonNull(str2,() -&gt; &#123; return "参数不能为空"; &#125;)); // abc&#125; 结论判断输入参数是否为空,需要配合lambda表达式一起使用. 结论Objects是JDK提供的操作Object常用方法的工具类,建议在使用Object常用方法时,优先使用Objects.]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ThreadLocal源码分析]]></title>
    <url>%2F2018%2F08%2F12%2FThreadLocal%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[概要 使用ThreadLocal可以实现多线程环境安全的共享对象. 实现原理是通过将对象的存储和访问分离,存储在线程对象中,对对象的操作在ThreadLocal对象中. 源码跟踪ThreadLocal的public方法如下: ThreadLocal的get方法123456789101112131415161718192021/** * Returns the value in the current thread's copy of this * thread-local variable. If the variable has no value for the * current thread, it is first initialized to the value returned * by an invocation of the &#123;@link #initialValue&#125; method. * * @return the current thread's value of this thread-local */public T get() &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings("unchecked") T result = (T)e.value; return result; &#125; &#125; return setInitialValue();&#125; 1.获取当前线程.2.调用getMap方法获取ThreadLocalMap.3.从ThreadLocalMap中获取需要的对象.ThreadLocal的getMap方法12345678910/** * Get the map associated with a ThreadLocal. Overridden in * InheritableThreadLocal. * * @param t the current thread * @return the map */ThreadLocalMap getMap(Thread t) &#123; return t.threadLocals;&#125; 访问入参的threadLocals成员变量(也就是当前线程的成员变量)Thread的threadLocals成员变量123/* ThreadLocal values pertaining to this thread. This map is maintained * by the ThreadLocal class. */ThreadLocal.ThreadLocalMap threadLocals = null; 从这里我们就可以看出存放实际对象是在Thread对象中,从而实现了不同线程使用不同的对象,达到了线程安全的目的,而对象实际存储的数据结构是ThreadLocal的内部类ThreadLocalMapThreadLocal的内部类ThreadLocalMap12345678910111213141516171819202122232425262728293031323334353637383940/** * ThreadLocalMap is a customized hash map suitable only for * maintaining thread local values. No operations are exported * outside of the ThreadLocal class. The class is package private to * allow declaration of fields in class Thread. To help deal with * very large and long-lived usages, the hash table entries use * WeakReferences for keys. However, since reference queues are not * used, stale entries are guaranteed to be removed only when * the table starts running out of space. */static class ThreadLocalMap &#123; /** * The entries in this hash map extend WeakReference, using * its main ref field as the key (which is always a * ThreadLocal object). Note that null keys (i.e. entry.get() * == null) mean that the key is no longer referenced, so the * entry can be expunged from table. Such entries are referred to * as "stale entries" in the code that follows. */ static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123; /** The value associated with this ThreadLocal. */ Object value; Entry(ThreadLocal&lt;?&gt; k, Object v) &#123; super(k); value = v; &#125; &#125; /** * The initial capacity -- MUST be a power of two. */ private static final int INITIAL_CAPACITY = 16; /** * The table, resized as necessary. * table.length MUST always be a power of two. */ private Entry[] table; 上面的代码是ThreadLocalMap的部分代码,可以从这部分代码中看到,实际存放数据的Entry的Key是一个ThreadLocal的弱引用,value是实际存储的对象.ThreadLocal的setInitialValue方法12345678910111213141516/** * Variant of set() to establish initialValue. Used instead * of set() in case user has overridden the set() method. * * @return the initial value */private T setInitialValue() &#123; T value = initialValue(); Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); return value;&#125; 该方法在get()的最后一行,当从当前线程获取的ThreadLocalMap没有获取到要获取的对象时,会调用该方法.可以看到该方法也是先从当前线程中获取ThreadLocalMap,如果为空,就调用createMap创建一个ThreadLocalMapThreadLocal的createMap方法12345678910/** * Create the map associated with a ThreadLocal. Overridden in * InheritableThreadLocal. * * @param t the current thread * @param firstValue value for the initial entry of the map */void createMap(Thread t, T firstValue) &#123; t.threadLocals = new ThreadLocalMap(this, firstValue);&#125; 可以看到,创建一个新的ThreadLocalMap,然后把它保存在当前线程的threadLocals成员变量里. ThreadLocal的set方法1234567891011121314151617/** * Sets the current thread's copy of this thread-local variable * to the specified value. Most subclasses will have no need to * override this method, relying solely on the &#123;@link #initialValue&#125; * method to set the values of thread-locals. * * @param value the value to be stored in the current thread's copy of * this thread-local. */public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value);&#125; 大致内容同get方法,获取当前线程保存的ThreadLocalMap对象,将实际对象保存到该Map中. TheadLocal的remove方法12345678910111213141516/** * Removes the current thread's value for this thread-local * variable. If this thread-local variable is subsequently * &#123;@linkplain #get read&#125; by the current thread, its value will be * reinitialized by invoking its &#123;@link #initialValue&#125; method, * unless its value is &#123;@linkplain #set set&#125; by the current thread * in the interim. This may result in multiple invocations of the * &#123;@code initialValue&#125; method in the current thread. * * @since 1.5 */ public void remove() &#123; ThreadLocalMap m = getMap(Thread.currentThread()); if (m != null) m.remove(this); &#125; 思路同get方法set方法. ThreadLocal的initialValue方法123456789101112131415161718192021/** * Returns the current thread's "initial value" for this * thread-local variable. This method will be invoked the first * time a thread accesses the variable with the &#123;@link #get&#125; * method, unless the thread previously invoked the &#123;@link #set&#125; * method, in which case the &#123;@code initialValue&#125; method will not * be invoked for the thread. Normally, this method is invoked at * most once per thread, but it may be invoked again in case of * subsequent invocations of &#123;@link #remove&#125; followed by &#123;@link #get&#125;. * * &lt;p&gt;This implementation simply returns &#123;@code null&#125;; if the * programmer desires thread-local variables to have an initial * value other than &#123;@code null&#125;, &#123;@code ThreadLocal&#125; must be * subclassed, and this method overridden. Typically, an * anonymous inner class will be used. * * @return the initial value for this thread-local */protected T initialValue() &#123; return null;&#125; 只有ThreadLocal的子类可以访问,获取默认的初始值. ThreadLocal的withInitial方法12345678910111213/** * Creates a thread local variable. The initial value of the variable is * determined by invoking the &#123;@code get&#125; method on the &#123;@code Supplier&#125;. * * @param &lt;S&gt; the type of the thread local's value * @param supplier the supplier to be used to determine the initial value * @return a new thread local variable * @throws NullPointerException if the specified supplier is null * @since 1.8 */public static &lt;S&gt; ThreadLocal&lt;S&gt; withInitial(Supplier&lt;? extends S&gt; supplier) &#123; return new SuppliedThreadLocal&lt;&gt;(supplier);&#125; JDK1.8后新增的一个创建ThreadLocal的工厂方法. 结论 通过上面的源码查看,可以看出ThreadLocal实现多线程共享成员变量的方式是,为每一个线程对保存一份变量.可以简单理解为线程堆. 最后,ThreadLocal类最值得学习的地方是将对象的存储和访问分离的设计方式.]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用builder模式构建javabean]]></title>
    <url>%2F2018%2F08%2F12%2F%E4%BD%BF%E7%94%A8builder%E6%A8%A1%E5%BC%8F%E6%9E%84%E5%BB%BAjavabean%2F</url>
    <content type="text"><![CDATA[概述使用private修饰构造器,使外部不能直接实例化Person对象.通过静态工厂方法,获取一个Builder的实例.通过Builder.build()方法发布Person对象. 代码演示123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384/** * 功能描述: 使用builder模式构建javabean * * @author sunzhiqiang * @create 2018-08-12 */public class Person2 &#123; private String name; private int age; private String sex; private Person2(PersonBuilder builder) &#123; this.name = builder.name; this.age = builder.age; this.sex = builder.sex; &#125; public static Person2.PersonBuilder getBuilder() &#123; return new PersonBuilder(); &#125; private static class PersonBuilder &#123; private String name; private int age; private String sex; public PersonBuilder name(String name) &#123; this.name = name; return this; &#125; public PersonBuilder age(int age) &#123; this.age = age; return this; &#125; public PersonBuilder sex(String sex) &#123; this.sex = sex; return this; &#125; public Person2 build() &#123; return new Person2(this); &#125; &#125; public String getName() &#123; return name; &#125; public int getAge() &#123; return age; &#125; public String getSex() &#123; return sex; &#125; @Override public String toString() &#123; return "Person2&#123;" + "name='" + name + '\'' + ", age=" + age + ", sex='" + sex + '\'' + '&#125;'; &#125; public static void main(String[] args) &#123; Person2 person2 = Person2.getBuilder() .name("李四") .age(10) .sex("不确定") .build(); System.out.println(person2); &#125;&#125; 当前类如果出现多个线程共享同一个builder,可能会导致线程不安全,而每一次调用工厂方法都new一个builder对象又有点浪费,下面我们使用ThreadLocal类来改写上面的代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293/** * 功能描述: 使用builder模式构建javabean * * @author sunzhiqiang * @create 2018-08-12 */public class Person2 &#123; private static final ThreadLocal&lt;PersonBuilder&gt; builder = new ThreadLocal&lt;PersonBuilder&gt;() &#123; @Override protected PersonBuilder initialValue() &#123; return new PersonBuilder(); &#125; &#125;; private String name; private int age; private String sex; private Person2(PersonBuilder builder) &#123; this.name = builder.name; this.age = builder.age; this.sex = builder.sex; &#125; public static Person2.PersonBuilder getBuilder() &#123; return builder.get(); &#125; private static class PersonBuilder &#123; private String name; private int age; private String sex; public PersonBuilder name(String name) &#123; this.name = name; return this; &#125; public PersonBuilder age(int age) &#123; this.age = age; return this; &#125; public PersonBuilder sex(String sex) &#123; this.sex = sex; return this; &#125; public Person2 build() &#123; return new Person2(this); &#125; &#125; public String getName() &#123; return name; &#125; public int getAge() &#123; return age; &#125; public String getSex() &#123; return sex; &#125; @Override public String toString() &#123; return "Person2&#123;" + "name='" + name + '\'' + ", age=" + age + ", sex='" + sex + '\'' + '&#125;'; &#125; public static void main(String[] args) &#123; Person2 person2 = Person2.getBuilder() .name("李四") .age(10) .sex("不确定") .build(); System.out.println(person2); &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java里4种引用类型]]></title>
    <url>%2F2018%2F08%2F11%2Fjava%E9%87%8C4%E7%A7%8D%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[引用类型分类1.强引用2.软引用3.弱引用4.虚引用 引用类型演示1.强引用1Test test = new Test(); 通过new关键字创造的引用为强引用,当GC进行垃圾收集的时候,只有发现没有任何引用指向该对象才可以进行垃圾回收.2.软引用1SoftReference&lt;Test&gt; test1 = new SoftReference&lt;Test&gt;(new Test()); 当GC进行垃圾回收时,如果这个时候,JVM内存充足,就不对该对象进行回收,否则进行回收.3.弱引用1WeakReference&lt;Test&gt; test2 = new WeakReference&lt;Test&gt;(new Test()); 每次进行GC都会回收弱引用.4.虚引用12ReferenceQueue&lt;Test&gt; rf = new ReferenceQueue&lt;Test&gt;();PhantomReference&lt;Test&gt; test3 = new PhantomReference&lt;Test&gt;(new Test(),rf); 如果一个对象只具有虚引用，那么它就和没有任何引用一样，随时会被jvm当作垃圾进行回收，虚引用主要是用于跟踪一个对象何时被GC回收.]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[适配器模式]]></title>
    <url>%2F2018%2F08%2F11%2F%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[模式的定义 将一个类的接口转换成客户希望的另外一个接口.Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作. 代码演示1.被适配接口1234567891011/** * 功能描述: 适配器模式 * 被适配接口 * * @author sunzhiqiang * @create 2018-08-11 */public interface AlternatingCurrent &#123; byte[] getAC();&#125; 12345678910111213/** * 功能描述: 适配器模式 * * @author sunzhiqiang * @create 2018-08-11 */public class ElectricCompary implements AlternatingCurrent &#123; public byte[] getAC() &#123; return new byte[]&#123;1,-1,3,-3,5,-2,6,-1,3,-2&#125;; &#125;&#125; 2.目标接口1234567891011/** * 功能描述: 适配器模式 * 目标接口 * * @author sunzhiqiang * @create 2018-08-11 */public interface DirectCurrent &#123; byte[] getDC();&#125; 3.适配器123456789101112131415161718192021222324252627/** * 功能描述: 适配器模式 * 适配器 * * @author sunzhiqiang * @create 2018-08-11 */public class ElectricAdapter implements DirectCurrent&#123; private AlternatingCurrent ac; public ElectricAdapter(AlternatingCurrent ac)&#123; this.ac = ac; &#125; public byte[] getDC() &#123; byte[] acCurrent = ac.getAC(); byte[] dcCurrent = new byte[acCurrent.length]; for (int i = 0; i &lt; acCurrent.length; i++) &#123; dcCurrent[i] = (byte) Math.abs(acCurrent[i]); &#125; return dcCurrent; &#125;&#125; 4.客户端1234567891011121314151617181920212223/** * 功能描述: 适配器模式 * 客户端 * * @author sunzhiqiang * @create 2018-08-11 */public class Computer &#123; public void play(DirectCurrent dc)&#123; byte[] array = dc.getDC(); System.out.println("使用直流电:" + Arrays.toString(array)); &#125; public static void main(String[] args)&#123; ElectricCompary electricCompary = new ElectricCompary(); Computer computer = new Computer(); computer.play(new ElectricAdapter(electricCompary)); &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDK动态代理源码分析]]></title>
    <url>%2F2018%2F08%2F11%2FJDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[概要jdk动态代理通过增加一个中间层,实现了被代理对象与代理对象解耦. 代码实现1.增加的调用处理器1234567891011121314151617181920/** * 功能描述: 动态代理 * * @author sunzhiqiang * @create 2018-08-09 */public class DynamicProxy implements InvocationHandler &#123; private Object obj; public DynamicProxy(Object obj) &#123; this.obj = obj; &#125; public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println("动态代理"); return method.invoke(obj, args); &#125;&#125; 直接与被代理对象交互的是InvocationHandler接口的实现类的对象 2.使用动态代理Phone是被代理的接口,只有一个方法1234public interface Phone &#123; void handlePhone();&#125; Boss是被代理对象,实现Phone接口123456public class Boss implements Phone &#123; public void handlePhone() &#123; System.out.println("老板接电话"); &#125;&#125; 使用调用处理器为Boss类生成对应的代理类123DynamicProxy handle = new DynamicProxy(new Boss()); Phone phone = (Phone) Proxy.newProxyInstance(Phone.class.getClassLoader(), new Class[]&#123;Phone.class&#125;, handle); phone.handlePhone(); 跟踪源码Proxy类的newProxyInstance方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@CallerSensitive public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentException &#123; Objects.requireNonNull(h); final Class&lt;?&gt;[] intfs = interfaces.clone(); final SecurityManager sm = System.getSecurityManager(); if (sm != null) &#123; checkProxyAccess(Reflection.getCallerClass(), loader, intfs); &#125; /* * Look up or generate the designated proxy class. */ Class&lt;?&gt; cl = getProxyClass0(loader, intfs); /* * Invoke its constructor with the designated invocation handler. */ try &#123; if (sm != null) &#123; checkNewProxyPermission(Reflection.getCallerClass(), cl); &#125; final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams); final InvocationHandler ih = h; if (!Modifier.isPublic(cl.getModifiers())) &#123; AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123; public Void run() &#123; cons.setAccessible(true); return null; &#125; &#125;); &#125; return cons.newInstance(new Object[]&#123;h&#125;); &#125; catch (IllegalAccessException|InstantiationException e) &#123; throw new InternalError(e.toString(), e); &#125; catch (InvocationTargetException e) &#123; Throwable t = e.getCause(); if (t instanceof RuntimeException) &#123; throw (RuntimeException) t; &#125; else &#123; throw new InternalError(t.toString(), t); &#125; &#125; catch (NoSuchMethodException e) &#123; throw new InternalError(e.toString(), e); &#125; &#125; 第9-13行,关于安全管理器的内容,感兴趣的同学可以看https://www.cnblogs.com/yiwangzhibujian/p/6207212.html第18行生成代理类的Class对象23行之后的代码通过反射生成代理类的对象Proxy类的getProxyClass0方法1234567891011private static Class&lt;?&gt; getProxyClass0(ClassLoader loader, Class&lt;?&gt;... interfaces) &#123; if (interfaces.length &gt; 65535) &#123; throw new IllegalArgumentException("interface limit exceeded"); &#125; // If the proxy class defined by the given loader implementing // the given interfaces exists, this will simply return the cached copy; // otherwise, it will create the proxy class via the ProxyClassFactory return proxyClassCache.get(loader, interfaces); &#125; 先检查接口数量是不是超过65535,再从proxyClassCache中获取代理类的Class对象Proxy的proxyClassCache成员变量12345/** * a cache of proxy classes */ private static final WeakCache&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt; proxyClassCache = new WeakCache&lt;&gt;(new KeyFactory(), new ProxyClassFactory()); WeakCache&lt;K, P, V&gt;的get(K,P)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public V get(K key, P parameter) &#123; Objects.requireNonNull(parameter); expungeStaleEntries(); Object cacheKey = CacheKey.valueOf(key, refQueue); // lazily install the 2nd level valuesMap for the particular cacheKey ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; valuesMap = map.get(cacheKey); if (valuesMap == null) &#123; ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; oldValuesMap = map.putIfAbsent(cacheKey, valuesMap = new ConcurrentHashMap&lt;&gt;()); if (oldValuesMap != null) &#123; valuesMap = oldValuesMap; &#125; &#125; // create subKey and retrieve the possible Supplier&lt;V&gt; stored by that // subKey from valuesMap Object subKey = Objects.requireNonNull(subKeyFactory.apply(key, parameter)); Supplier&lt;V&gt; supplier = valuesMap.get(subKey); Factory factory = null; while (true) &#123; if (supplier != null) &#123; // supplier might be a Factory or a CacheValue&lt;V&gt; instance V value = supplier.get(); if (value != null) &#123; return value; &#125; &#125; // else no supplier in cache // or a supplier that returned null (could be a cleared CacheValue // or a Factory that wasn't successful in installing the CacheValue) // lazily construct a Factory if (factory == null) &#123; factory = new Factory(key, parameter, subKey, valuesMap); &#125; if (supplier == null) &#123; supplier = valuesMap.putIfAbsent(subKey, factory); if (supplier == null) &#123; // successfully installed Factory supplier = factory; &#125; // else retry with winning supplier &#125; else &#123; if (valuesMap.replace(subKey, supplier, factory)) &#123; // successfully replaced // cleared CacheEntry / unsuccessful Factory // with our Factory supplier = factory; &#125; else &#123; // retry with current supplier supplier = valuesMap.get(subKey); &#125; &#125; &#125; &#125; 大致意思通过Key获取ValueMap,再调用Proxy.KeyFactory生成一个subKey,通过subKey从valueMap中获取value.如何value为空,就创建一个WeakCache.Factory类的对象.WeakCache.Factory类的get方法1234567891011121314151617181920212223242526272829303132333435363738394041@Override public synchronized V get() &#123; // serialize access // re-check Supplier&lt;V&gt; supplier = valuesMap.get(subKey); if (supplier != this) &#123; // something changed while we were waiting: // might be that we were replaced by a CacheValue // or were removed because of failure -&gt; // return null to signal WeakCache.get() to retry // the loop return null; &#125; // else still us (supplier == this) // create new value V value = null; try &#123; value = Objects.requireNonNull(valueFactory.apply(key, parameter)); &#125; finally &#123; if (value == null) &#123; // remove us on failure valuesMap.remove(subKey, this); &#125; &#125; // the only path to reach here is with non-null value assert value != null; // wrap value with CacheValue (WeakReference) CacheValue&lt;V&gt; cacheValue = new CacheValue&lt;&gt;(value); // try replacing us with CacheValue (this should always succeed) if (valuesMap.replace(subKey, this, cacheValue)) &#123; // put also in reverseMap reverseMap.put(cacheValue, Boolean.TRUE); &#125; else &#123; throw new AssertionError("Should not reach here"); &#125; // successfully replaced us with new CacheValue -&gt; return the value // wrapped by it return value; &#125; 关键的部分是第18行,通过调用Proxy.ProxyClassFactory的apply方法产生一个value.Proxy.ProxyClassFactory的apply方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889@Override public Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123; Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = new IdentityHashMap&lt;&gt;(interfaces.length); for (Class&lt;?&gt; intf : interfaces) &#123; /* * Verify that the class loader resolves the name of this * interface to the same Class object. */ Class&lt;?&gt; interfaceClass = null; try &#123; interfaceClass = Class.forName(intf.getName(), false, loader); &#125; catch (ClassNotFoundException e) &#123; &#125; if (interfaceClass != intf) &#123; throw new IllegalArgumentException( intf + " is not visible from class loader"); &#125; /* * Verify that the Class object actually represents an * interface. */ if (!interfaceClass.isInterface()) &#123; throw new IllegalArgumentException( interfaceClass.getName() + " is not an interface"); &#125; /* * Verify that this interface is not a duplicate. */ if (interfaceSet.put(interfaceClass, Boolean.TRUE) != null) &#123; throw new IllegalArgumentException( "repeated interface: " + interfaceClass.getName()); &#125; &#125; String proxyPkg = null; // package to define proxy class in int accessFlags = Modifier.PUBLIC | Modifier.FINAL; /* * Record the package of a non-public proxy interface so that the * proxy class will be defined in the same package. Verify that * all non-public proxy interfaces are in the same package. */ for (Class&lt;?&gt; intf : interfaces) &#123; int flags = intf.getModifiers(); if (!Modifier.isPublic(flags)) &#123; accessFlags = Modifier.FINAL; String name = intf.getName(); int n = name.lastIndexOf('.'); String pkg = ((n == -1) ? "" : name.substring(0, n + 1)); if (proxyPkg == null) &#123; proxyPkg = pkg; &#125; else if (!pkg.equals(proxyPkg)) &#123; throw new IllegalArgumentException( "non-public interfaces from different packages"); &#125; &#125; &#125; if (proxyPkg == null) &#123; // if no non-public proxy interfaces, use com.sun.proxy package proxyPkg = ReflectUtil.PROXY_PACKAGE + "."; &#125; /* * Choose a name for the proxy class to generate. */ long num = nextUniqueNumber.getAndIncrement(); String proxyName = proxyPkg + proxyClassNamePrefix + num; /* * Generate the specified proxy class. */ byte[] proxyClassFile = ProxyGenerator.generateProxyClass( proxyName, interfaces, accessFlags); try &#123; return defineClass0(loader, proxyName, proxyClassFile, 0, proxyClassFile.length); &#125; catch (ClassFormatError e) &#123; /* * A ClassFormatError here means that (barring bugs in the * proxy class generation code) there was some other * invalid aspect of the arguments supplied to the proxy * class creation (such as virtual machine limitations * exceeded). */ throw new IllegalArgumentException(e.toString()); &#125; &#125; 第一步验证传入的参数是不是接口,有没有重复,能不能被当前的类加载器加载.第二步生成代理类的包名:1.如果被代理的接口是public,代理类的报名就是com.sun.proxy1proxyPkg = ReflectUtil.PROXY_PACKAGE + "."; 1public static final String PROXY_PACKAGE = "com.sun.proxy"; 2.如果被代理的接口不是public的,代理类与被代理的接口在相同的包下.第三步,生成代理类的名字,$Proxy + 一个递增的数字第四步调用native方法生成class文件Proxy的defineClass0方法12private static native Class&lt;?&gt; defineClass0(ClassLoader loader, String name, byte[] b, int off, int len); 查看动态生成的代理类的class文件1.设置启动时候的JVM参数1-Dsun.misc.ProxyGenerator.saveGeneratedFiles=true 2.执行Proxy.newProxyInstance方法3.生成的代理类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package com.sun.proxy;import cn.com.sunzhiqiang.pattern.proxy.Phone;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.lang.reflect.UndeclaredThrowableException;public final class $Proxy0 extends Proxy implements Phone &#123; private static Method m1; private static Method m2; private static Method m3; private static Method m0; public $Proxy0(InvocationHandler var1) throws &#123; super(var1); &#125; public final boolean equals(Object var1) throws &#123; try &#123; return (Boolean)super.h.invoke(this, m1, new Object[]&#123;var1&#125;); &#125; catch (RuntimeException | Error var3) &#123; throw var3; &#125; catch (Throwable var4) &#123; throw new UndeclaredThrowableException(var4); &#125; &#125; public final String toString() throws &#123; try &#123; return (String)super.h.invoke(this, m2, (Object[])null); &#125; catch (RuntimeException | Error var2) &#123; throw var2; &#125; catch (Throwable var3) &#123; throw new UndeclaredThrowableException(var3); &#125; &#125; public final void handlePhone() throws &#123; try &#123; super.h.invoke(this, m3, (Object[])null); &#125; catch (RuntimeException | Error var2) &#123; throw var2; &#125; catch (Throwable var3) &#123; throw new UndeclaredThrowableException(var3); &#125; &#125; public final int hashCode() throws &#123; try &#123; return (Integer)super.h.invoke(this, m0, (Object[])null); &#125; catch (RuntimeException | Error var2) &#123; throw var2; &#125; catch (Throwable var3) &#123; throw new UndeclaredThrowableException(var3); &#125; &#125; static &#123; try &#123; m1 = Class.forName("java.lang.Object").getMethod("equals", Class.forName("java.lang.Object")); m2 = Class.forName("java.lang.Object").getMethod("toString"); m3 = Class.forName("cn.com.sunzhiqiang.pattern.proxy.Phone").getMethod("handlePhone"); m0 = Class.forName("java.lang.Object").getMethod("hashCode"); &#125; catch (NoSuchMethodException var2) &#123; throw new NoSuchMethodError(var2.getMessage()); &#125; catch (ClassNotFoundException var3) &#123; throw new NoClassDefFoundError(var3.getMessage()); &#125; &#125;&#125; 如上,第39到47行,代理类将代理方法的具体处理委派给了InvocationHandler的invoke方法. 结论JDK的动态代理通过增加一层InvocationHandler,实现了被代理对象和代理对象之间的解耦.]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代理模式]]></title>
    <url>%2F2018%2F08%2F09%2F%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[模式的定义: 为其他对象提供一种代理以控制对这个对象的访问. 代码演示:1.被代理的接口1234public interface Phone &#123; void handlePhone();&#125; 2.被代理的类123456789101112/** * 功能描述: 代理模式 * * @author sunzhiqiang * @create 2018-08-09 */public class Boss implements Phone &#123; public void handlePhone() &#123; System.out.println("老板接电话"); &#125;&#125; 3.代理类12345678910111213141516171819/** * 功能描述: 代理模式 * * @author sunzhiqiang * @create 2018-08-09 */public class Secretary implements Phone &#123; private Phone boss; public Secretary(Phone boss)&#123; this.boss = boss; &#125; public void handlePhone()&#123; System.out.println("秘书先处理一部分电话"); boss.handlePhone();//老板在秘书处理之后再回复电话 &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模板方法模式]]></title>
    <url>%2F2018%2F08%2F09%2F%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[模式的定义: 定义一个操作中算法的骨架,而将一些步骤延迟到子类中.模板方法使子类可以不改变一个算法的结构即可重新定义该算法的某些特定步骤. 代码演示:1.没有钩子方法1234567891011121314151617181920212223242526272829303132333435/** * 功能描述: 模板方法模式 * * @author sunzhiqiang * @create 2018-08-06 */public abstract class TemplatePattern &#123; public void process() &#123; preprocessImpl(); processImpl(); postprocessImpl(); &#125; public abstract void preprocessImpl(); public abstract void processImpl(); public abstract void postprocessImpl();&#125;class TemplateImpl extends TemplatePattern &#123; public void preprocessImpl() &#123; System.out.println("前置处理"); &#125; public void processImpl() &#123; System.out.println("处理中"); &#125; public void postprocessImpl() &#123; System.out.println("后置处理"); &#125;&#125; 2.有钩子方法12345678910111213141516171819202122232425262728293031/** * 功能描述: 模板方法模式 * * @author sunzhiqiang * @create 2018-08-06 */public abstract class TemplatePattern2 &#123; public void process() &#123; preprocessImpl(); processImpl(); postprocessImpl(); &#125; public void preprocessImpl()&#123; &#125; public abstract void processImpl(); public void postprocessImpl()&#123; &#125;&#125;class TemplateImpl2 extends TemplatePattern2 &#123; public void processImpl() &#123; System.out.println("具体的处理"); &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单例模式]]></title>
    <url>%2F2018%2F08%2F01%2F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[模式的定义: 保证一个类仅有一个实例,并提供一个访问它的全局访问点. 代码演示:1.饿汉式1234567891011121314151617/** * 功能描述: 单例模式(饿汉式) * * @author sunzhiqiang * @create 2018-08-05 */public final class Singleton1 &#123; private final static Singleton1 INSTANCE = new Singleton1(); private Singleton1()&#123; &#125; public static Singleton1 getInstance()&#123; return INSTANCE; &#125;&#125; 2.懒汉式12345678910111213141516171819202122232425/** * 功能描述: 单例模式(懒汉式) * * @author sunzhiqiang * @create 2018-08-05 */public final class Singleton2 &#123; private static Singleton2 INSTANCE = null; private Singleton2()&#123; &#125; public static Singleton2 getInstance()&#123; if(INSTANCE == null)&#123; synchronized (Singleton2.class)&#123; if(INSTANCE == null)&#123; INSTANCE = new Singleton2(); &#125; &#125; &#125; return INSTANCE; &#125;&#125; 3.静态内部类12345678910111213141516171819/** * 功能描述: 单例模式(静态内部类) * * @author sunzhiqiang * @create 2018-08-05 */public class Singleton3 &#123; private Singleton3()&#123; &#125; public static Singleton3 getInstance()&#123; return Singleton3Holder.INSTANCE; &#125; private static class Singleton3Holder&#123; private static final Singleton3 INSTANCE = new Singleton3(); &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式总览]]></title>
    <url>%2F2018%2F07%2F30%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E8%A7%88%2F</url>
    <content type="text"><![CDATA[GoF设计模式学习创建型模式: 工厂方法模式 定义一个用于创建对象的接口,让子类决定实例化哪一个类.Factory Method使一个类的实例化延迟到其子类 抽象工厂模式 提供一个创建一系列或相互依赖对象的接口,而无须指定它们具体的类. 生成器模式 将一个复杂对象的构建与它的表示分离,使同样的构建过程可以创建不同的表示. 原型模式 用原型实例指定创建对象的种类,并且通过复制这些原型创建新的对象. 单例模式 保证一个类仅有一个实例,并提供一个访问它的全局访问点. 行为型模式: 责任链模式 使多个对象都有机会处理请求,从而避免请求的发送者和接收者之间的耦合关系.将这些对象连成一条链,并沿着这条链传递该请求,直到有一个对象处理它为止. 命令模式 将一个请求封装为一个对象,从而使用户可用不同的请求对客户进行参数化;对请求排队或记录请求日志,以及支持可撤销的操作. 解释器模式 给定一个语言,定义它的文法的一种表示,并定义一个解释器,这个解释器使用该表示来解释语句中的句子. 迭代器模式 提供一种方法顺序访问一个聚合对象中的各个元素,而又不需要暴露该对象的内部表示. 中介者模式 用一个中介对象来封装一系列的对象交互.中介者使各对象不需要显示地相互引用,从而使其耦合松散,而且可以独立地改变它们之间的交互. 备忘录模式 在不破坏封装性的前提下,捕获一个对象的内部状态,并在该对象之外保存这个状态,这样以后就可将该对象恢复到原先保存的状态. 观察者模式 定义对象间的一种一对多的依赖关系,当一个对象的状态发生变化时,所有依赖它的对象都得到通知并自动更新. 状态模式 允许一个对象在其内部状态改变时改变它的行为,对象看起来似乎修改了它的类. 策略模式 定义一系列算法,把它们一个个封装起来,并且使它们可相互替换.本模式使得算法可独立于使用它的客户而变化. 模板方法模式 定义一个操作中算法的骨架,而将一些步骤延迟到子类中.模板方法使子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤. 访问者模式 表示一个作用于某对象结构中的各个元素的操作.它可以在不改变各个元素的类的前提下定义作用于这些元素的新操作. 结构型模式: 适配器模式 将一个类的接口装换成客户希望的另外一个接口.Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作. 组合模式 将对象组合成树形结构以表示”部分-整体”的层次结构.Composite使用户对单个对象和组合对象的使用具有一致性. 代理模式 为其他对象提供一种代理以控制对这个对象的访问. 享元模式 运用共享技术有效地支持大量细粒度的对象. 外观模式 为系统中的一组接口提供一个一致的界面,Facade模式定义了一个高层接口,这个接口使得这一子系统更加容易使用. 桥接模式 将抽象部分与它的实现部分分离,使它们都可以独立地变化. 装饰模式 动态地给对象添加一些额外的职责.就功能来说装饰模式相比生成子类更为灵活.]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
</search>
